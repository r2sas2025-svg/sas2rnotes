---
title: "Creating R Packages"
---

# Introduction to R Package Development

R packages are the fundamental units of reproducible R code. They provide a structured way to organize functions, data, documentation, and tests.  In pharmaceutical programming, creating packages is essential for: 

- **Standardizing analysis methods** across studies and therapeutic areas
- **Ensuring reproducibility** of statistical analyses
- **Facilitating code review** and validation processes
- **Sharing validated tools** across teams and organizations
- **Meeting regulatory requirements** for documented and tested code

This guide covers the complete process of creating, documenting, testing, and deploying R packages with a focus on pharmaceutical applications.

## Prerequisites

Before starting, ensure you have the necessary tools installed:

```{r,eval=FALSE}
# Install essential package development tools
install.packages(c(
  "devtools",    # Package development tools
  "usethis",     # Workflow automation
  "roxygen2",    # Documentation
  "testthat",    # Unit testing
  "pkgdown",     # Package website
  "covr"         # Test coverage
))

# Load the primary development package
library(devtools)
library(usethis)
```

# Package Structure and Essential Files

## Creating a New Package

### Basic Package Creation

```{r,eval=FALSE}
# Create a new package in the current directory
usethis::create_package("pharmaTools")

# Or specify a path
usethis::create_package("~/projects/pharmaTools")
```

This creates the basic package structure: 

```
pharmaTools/
├── DESCRIPTION
├── NAMESPACE
├── R/
├── man/
└── pharmaTools. Rproj
```

## Essential Package Files

### 1. DESCRIPTION File

The DESCRIPTION file contains metadata about your package. 

```{r}
# Example DESCRIPTION file for a pharmaceutical package
```

```
Package: pharmaTools
Type:  Package
Title: Statistical Tools for Pharmaceutical Data Analysis
Version: 0.1.0
Authors@R: c(
    person("Jane", "Doe", email = "jane.doe@pharma.com", 
           role = c("aut", "cre"),
           comment = c(ORCID = "0000-0000-0000-0000")),
    person("John", "Smith", email = "john. smith@pharma.com", 
           role = "aut")
    )
Description: Provides standardized functions for pharmaceutical data analysis
    including CDISC data processing, pharmacokinetic calculations, 
    adverse event analysis, and regulatory table generation.
    Designed to meet FDA and EMA statistical requirements.
License: MIT + file LICENSE
Encoding: UTF-8
LazyData: true
Roxygen: list(markdown = TRUE)
RoxygenNote: 7.2.3
Depends: 
    R (>= 4.0.0)
Imports: 
    dplyr (>= 1.0.0),
    tidyr (>= 1.0.0),
    rlang (>= 0.4.0),
    glue (>= 1.4.0)
Suggests: 
    testthat (>= 3.0.0),
    knitr,
    rmarkdown,
    covr
VignetteBuilder: knitr
URL: https://github.com/pharma/pharmaTools
BugReports: https://github.com/pharma/pharmaTools/issues
```

### 2. NAMESPACE File

The NAMESPACE file controls which functions are exported (available to users) and which packages are imported.  **Never edit this file manually** - it's managed by roxygen2.

```{r}
# NAMESPACE is automatically generated from roxygen2 comments
# Example content (auto-generated):
```

```
# Generated by roxygen2: do not edit by hand

export(calculate_pk_parameters)
export(summarize_adverse_events)
import(dplyr)
importFrom(rlang, enquo)
importFrom(glue, glue)
```

### 3. R Directory

The `R/` directory contains all your R code files.  Organize functions logically:

```
R/
├── pk-functions.R          # Pharmacokinetic calculations
├── ae-functions.R          # Adverse event analysis
├── demographics.R          # Demographic summaries
├── utils.R                 # Utility functions
├── data. R                  # Data documentation
└── pharmaTools-package.R   # Package documentation
```

### 4. Setting Up Additional Directories

```{r,eval=FALSE}
# Create additional standard directories
usethis::use_data_raw()      # For data preparation scripts
usethis::use_vignette("introduction")  # For tutorials
usethis::use_news_md()       # For change log
usethis::use_readme_rmd()    # For README
```

## Example:  Creating a Pharmaceutical Package

Let's create a complete example package for adverse event analysis:

```{r,eval=FALSE}
# Step 1: Create the package
usethis::create_package("aeAnalysis")

# Step 2: Set up Git version control
usethis::use_git()

# Step 3: Add a license
usethis::use_mit_license("Your Name")

# Step 4: Set up testing infrastructure
usethis::use_testthat()

# Step 5: Create package documentation
usethis::use_package_doc()

# Step 6: Set up a README
usethis:: use_readme_rmd()

# Step 7: Add dependencies
usethis::use_package("dplyr", type = "Imports")
usethis::use_package("tidyr", type = "Imports")
usethis::use_package("haven", type = "Suggests")
```

# Documenting Functions with roxygen2

Roxygen2 uses special comments above functions to generate documentation automatically. 

## Basic roxygen2 Syntax

### Simple Function Documentation

```{r,eval=FALSE}
#' Calculate Body Mass Index (BMI)
#'
#' @description
#' Calculates BMI from weight and height measurements for clinical trials.
#'
#' @param weight Numeric vector of weights in kilograms
#' @param height Numeric vector of heights in meters
#'
#' @return Numeric vector of BMI values (kg/m²)
#'
#' @examples
#' calculate_bmi(weight = 70, height = 1.75)
#' calculate_bmi(weight = c(65, 80, 75), height = c(1.68, 1.82, 1.70))
#'
#' @export
calculate_bmi <- function(weight, height) {
  # Input validation
  if (!is.numeric(weight) || !is.numeric(height)) {
    stop("Weight and height must be numeric values")
  }
  
  if (any(weight <= 0, na.rm = TRUE) || any(height <= 0, na.rm = TRUE)) {
    stop("Weight and height must be positive values")
  }
  
  # Calculate BMI
  bmi <- weight / (height^2)
  
  return(bmi)
}
```

### Key roxygen2 Tags

- `@param` - Parameter description
- `@return` - Return value description
- `@examples` - Usage examples
- `@export` - Make function available to users
- `@import` - Import entire package
- `@importFrom` - Import specific functions
- `@author` - Function author
- `@seealso` - Related functions
- `@references` - Citations
- `@keywords` - Keywords for searching

## Advanced Documentation Examples

### Pharmacokinetic Function with Detailed Documentation

```{r,eval=FALSE}
#' Calculate Pharmacokinetic Parameters
#'
#' @description
#' Calculates standard non-compartmental pharmacokinetic (PK) parameters
#' from concentration-time data according to FDA and EMA guidelines.
#'
#' @param time Numeric vector of time points (hours)
#' @param concentration Numeric vector of drug concentrations (ng/mL or µg/mL)
#' @param dose Numeric.  Administered dose (mg)
#' @param method Character. Integration method:  "linear" (default) or "log"
#' @param unit_time Character. Time unit: "h" (hours), "min" (minutes), "day" (days)
#'
#' @details
#' This function calculates the following PK parameters:
#' \itemize{
#'   \item \strong{Cmax}:  Maximum observed concentration
#'   \item \strong{Tmax}: Time of maximum concentration
#'   \item \strong{AUC0-t}: Area under the curve from time 0 to last measurable concentration
#'   \item \strong{AUC0-inf}: Area under the curve from time 0 to infinity
#'   \item \strong{t_half}: Terminal elimination half-life
#'   \item \strong{CL/F}: Apparent clearance
#'   \item \strong{Vd/F}: Apparent volume of distribution
#' }
#'
#' The AUC is calculated using the linear trapezoidal rule for ascending
#' concentrations and log-trapezoidal rule for descending concentrations
#' when method = "linear".
#'
#' @return A list containing:
#' \describe{
#'   \item{Cmax}{Maximum concentration}
#'   \item{Tmax}{Time of maximum concentration}
#'   \item{AUC_0_t}{AUC from 0 to last measurable time point}
#'   \item{AUC_0_inf}{AUC extrapolated to infinity}
#'   \item{t_half}{Terminal half-life}
#'   \item{lambda_z}{Terminal elimination rate constant}
#'   \item{CL_F}{Apparent clearance}
#'   \item{Vd_F}{Apparent volume of distribution}
#' }
#'
#' @examples
#' # Single dose PK profile
#' time <- c(0, 0.5, 1, 2, 4, 8, 12, 24)
#' conc <- c(0, 85, 100, 90, 70, 45, 28, 10)
#'
#' pk_params <- calculate_pk_parameters(
#'   time = time,
#'   concentration = conc,
#'   dose = 500
#' )
#'
#' print(pk_params)
#'
#' # Multiple subject data (using lapply)
#' subjects <- list(
#'   list(time = c(0, 1, 2, 4, 8), conc = c(0, 95, 88, 65, 35)),
#'   list(time = c(0, 1, 2, 4, 8), conc = c(0, 102, 95, 72, 40))
#' )
#'
#' results <- lapply(subjects, function(s) {
#'   calculate_pk_parameters(s$time, s$conc, dose = 500)
#' })
#'
#' @references
#' \itemize{
#'   \item FDA (2003). Guidance for Industry: Bioavailability and 
#'         Bioequivalence Studies for Orally Administered Drug Products
#'   \item Gabrielsson, J., & Weiner, D. (2012). Pharmacokinetic and 
#'         Pharmacodynamic Data Analysis: Concepts and Applications (5th ed.)
#' }
#'
#' @seealso
#' \code{\link{simulate_pk_profile}} for simulating PK profiles
#'
#' @author Jane Doe \email{jane.doe@@pharma.com}
#'
#' @keywords pharmacokinetics noncompartmental
#'
#' @export
calculate_pk_parameters <- function(time, 
                                    concentration, 
                                    dose, 
                                    method = "linear",
                                    unit_time = "h") {
  
  # Input validation
  if (length(time) != length(concentration)) {
    stop("Time and concentration vectors must have the same length")
  }
  
  if (any(time < 0, na.rm = TRUE)) {
    stop("Time values must be non-negative")
  }
  
  if (any(concentration < 0, na.rm = TRUE)) {
    warning("Negative concentrations detected. Setting to zero.")
    concentration[concentration < 0] <- 0
  }
  
  # Remove missing values
  valid_idx <- !is.na(time) & !is.na(concentration)
  time <- time[valid_idx]
  concentration <- concentration[valid_idx]
  
  # Sort by time
  ord <- order(time)
  time <- time[ord]
  concentration <- concentration[ord]
  
  # Calculate Cmax and Tmax
  cmax <- max(concentration, na.rm = TRUE)
  tmax <- time[which.max(concentration)]
  
  # Calculate AUC using trapezoidal rule
  auc_0_t <- 0
  for (i in 2:length(time)) {
    dt <- time[i] - time[i-1]
    
    if (method == "linear") {
      # Linear trapezoidal
      auc_segment <- dt * (concentration[i] + concentration[i-1]) / 2
    } else if (method == "log") {
      # Log trapezoidal (for descending concentrations)
      if (concentration[i] > 0 && concentration[i-1] > 0) {
        auc_segment <- dt * (concentration[i] - concentration[i-1]) / 
                      log(concentration[i] / concentration[i-1])
      } else {
        auc_segment <- dt * (concentration[i] + concentration[i-1]) / 2
      }
    }
    
    auc_0_t <- auc_0_t + auc_segment
  }
  
  # Estimate terminal elimination rate constant (lambda_z)
  # Use last 3-5 points for regression
  n_points <- min(5, floor(length(time) * 0.4))
  term_idx <- (length(time) - n_points + 1):length(time)
  
  # Remove zero concentrations for log transformation
  term_idx <- term_idx[concentration[term_idx] > 0]
  
  if (length(term_idx) >= 3) {
    log_conc <- log(concentration[term_idx])
    term_time <- time[term_idx]
    
    # Linear regression on log-transformed data
    fit <- lm(log_conc ~ term_time)
    lambda_z <- -coef(fit)[2]
    
    # Calculate terminal half-life
    t_half <- log(2) / lambda_z
    
    # Extrapolate AUC to infinity
    c_last <- concentration[length(concentration)]
    auc_extrap <- c_last / lambda_z
    auc_0_inf <- auc_0_t + auc_extrap
    
    # Calculate clearance and volume of distribution
    cl_f <- dose / auc_0_inf
    vd_f <- dose / (lambda_z * auc_0_inf)
    
  } else {
    lambda_z <- NA
    t_half <- NA
    auc_0_inf <- NA
    cl_f <- NA
    vd_f <- NA
  }
  
  # Return results
  results <- list(
    Cmax = cmax,
    Tmax = tmax,
    AUC_0_t = auc_0_t,
    AUC_0_inf = auc_0_inf,
    t_half = t_half,
    lambda_z = lambda_z,
    CL_F = cl_f,
    Vd_F = vd_f
  )
  
  # Add attributes for units
  attr(results, "time_unit") <- unit_time
  attr(results, "dose") <- dose
  
  return(results)
}
```

### Adverse Event Summary Function

```{r,eval=FALSE}
#' Summarize Adverse Events by Treatment Group
#'
#' @description
#' Creates a summary table of adverse events by treatment group,
#' including subject counts and percentages.  Suitable for regulatory
#' submissions.
#'
#' @param data Data frame containing adverse event data
#' @param ae_term Character. Name of column containing AE terms (default: "AEDECOD")
#' @param treatment Character. Name of column containing treatment groups (default: "TRTA")
#' @param subject_id Character. Name of column containing subject IDs (default: "USUBJID")
#' @param min_pct Numeric. Minimum percentage to include in table (default: 0)
#' @param sort_by Character. Sort results by:  "frequency" (default), "alphabetical", or "none"
#'
#' @return A data frame with columns:
#' \itemize{
#'   \item ae_term:  Adverse event preferred term
#'   \item One column per treatment group with n (%) format
#'   \item total_n: Total number of subjects with the AE
#' }
#'
#' @examples
#' \dontrun{
#' # Load ADAE dataset
#' adae <- haven::read_sas("data/adam/adae.sas7bdat")
#'
#' # Summarize all AEs
#' ae_summary <- summarize_adverse_events(
#'   data = adae,
#'   ae_term = "AEDECOD",
#'   treatment = "TRTA"
#' )
#'
#' # Summarize AEs occurring in >= 5% of subjects
#' ae_summary_common <- summarize_adverse_events(
#'   data = adae,
#'   ae_term = "AEDECOD",
#'   treatment = "TRTA",
#'   min_pct = 5
#' )
#' }
#'
#' @importFrom dplyr group_by summarize n_distinct left_join arrange desc
#' @importFrom tidyr pivot_wider
#' @importFrom rlang sym : =
#'
#' @export
summarize_adverse_events <- function(data,
                                     ae_term = "AEDECOD",
                                     treatment = "TRTA",
                                     subject_id = "USUBJID",
                                     min_pct = 0,
                                     sort_by = "frequency") {
  
  # Validate inputs
  if (! is.data.frame(data)) {
    stop("data must be a data frame")
  }
  
  required_cols <- c(ae_term, treatment, subject_id)
  missing_cols <- setdiff(required_cols, names(data))
  
  if (length(missing_cols) > 0) {
    stop(paste("Missing required columns:", paste(missing_cols, collapse = ", ")))
  }
  
  # Calculate N per treatment group
  n_subj <- data %>%
    dplyr::group_by(!! rlang::sym(treatment)) %>%
    dplyr:: summarize(N = dplyr::n_distinct(!!rlang::sym(subject_id)), .groups = "drop")
  
  # Count subjects with each AE by treatment
  ae_counts <- data %>%
    dplyr:: group_by(!!rlang::sym(treatment), !!rlang::sym(ae_term)) %>%
    dplyr::summarize(n = dplyr::n_distinct(!!rlang::sym(subject_id)), .groups = "drop") %>%
    dplyr::left_join(n_subj, by = treatment) %>%
    dplyr::mutate(
      pct = round(n / N * 100, 1),
      display = paste0(n, " (", format(pct, nsmall = 1), "%)")
    )
  
  # Filter by minimum percentage if specified
  if (min_pct > 0) {
    ae_counts <- ae_counts %>%
      dplyr::group_by(!!rlang:: sym(ae_term)) %>%
      dplyr::filter(any(pct >= min_pct)) %>%
      dplyr:: ungroup()
  }
  
  # Pivot wider to get one column per treatment
  ae_wide <- ae_counts %>%
    dplyr::select(!!rlang::sym(treatment), !!rlang::sym(ae_term), display, n) %>%
    tidyr::pivot_wider(
      names_from = !!rlang:: sym(treatment),
      values_from = display,
      values_fill = "0 (0. 0%)"
    )
  
  # Calculate total across treatments for sorting
  ae_totals <- ae_counts %>%
    dplyr:: group_by(!!rlang::sym(ae_term)) %>%
    dplyr::summarize(total_n = sum(n), .groups = "drop")
  
  # Join with totals
  result <- ae_wide %>%
    dplyr::left_join(ae_totals, by = ae_term)
  
  # Apply sorting
  if (sort_by == "frequency") {
    result <- result %>%
      dplyr::arrange(dplyr::desc(total_n), !!rlang::sym(ae_term))
  } else if (sort_by == "alphabetical") {
    result <- result %>%
      dplyr::arrange(!!rlang::sym(ae_term))
  }
  
  return(result)
}
```

### Package-Level Documentation

```{r,eval=FALSE}
#' @keywords internal
"_PACKAGE"

# The following block is used by usethis to automatically manage
# roxygen namespace tags.  Modify with care!
## usethis namespace: start
#' @importFrom dplyr %>%
## usethis namespace: end
NULL
```

## Documenting Datasets

```{r,eval=FALSE}
#' Example Adverse Event Dataset
#'
#' @description
#' A sample adverse event dataset following CDISC ADaM standards (ADAE).
#' Contains 150 adverse event records from a clinical trial comparing
#' two doses of an investigational drug versus placebo.
#'
#' @format A data frame with 150 rows and 10 variables:
#' \describe{
#'   \item{USUBJID}{Unique subject identifier}
#'   \item{TRTA}{Actual treatment received}
#'   \item{AEDECOD}{Adverse event preferred term (MedDRA)}
#'   \item{AEBODSYS}{Adverse event body system/organ class}
#'   \item{AESEV}{Severity:  MILD, MODERATE, or SEVERE}
#'   \item{AESER}{Serious adverse event:  Y or N}
#'   \item{AEREL}{Relationship to study drug:  RELATED or NOT RELATED}
#'   \item{ASTDY}{Study day of AE start}
#'   \item{AENDY}{Study day of AE end}
#'   \item{AEOUT}{Outcome:  RECOVERED, RECOVERING, NOT RECOVERED}
#' }
#'
#' @source Simulated data based on typical clinical trial adverse event patterns
#'
#' @examples
#' data(example_adae)
#' head(example_adae)
#'
#' # Summarize by treatment
#' table(example_adae$TRTA, example_adae$AESEV)
#'
"example_adae"
```

## Generating Documentation

```{r,eval=FALSE}
# Generate documentation from roxygen2 comments
devtools::document()

# This does three things:
# 1. Creates . Rd files in man/ directory
# 2. Updates NAMESPACE file
# 3. Updates documentation index
```

# Building and Installing Packages

## Building Your Package

### Check Package Validity

```{r,eval=FALSE}
# Run comprehensive package checks
devtools::check()

# This checks:
# - Package structure
# - Documentation completeness
# - Code quality
# - Examples run successfully
# - Tests pass
# - No warnings or errors
```

### Install the Package Locally

```{r,eval=FALSE}
# Install from source
devtools::install()

# Install and restart R session
devtools::install(reload = TRUE)

# Install with vignettes
devtools::install(build_vignettes = TRUE)
```

### Build Package Tarball

```{r,eval=FALSE}
# Build source package (. tar.gz)
devtools::build()

# Build binary package
devtools::build(binary = TRUE)

# Build for CRAN submission (includes manual)
devtools::build(manual = TRUE, vignettes = TRUE)
```

## Loading Your Package During Development

```{r,eval=FALSE}
# Load all package functions without installing
devtools::load_all()

# This is faster during development
# Keyboard shortcut: Ctrl+Shift+L (Windows/Linux) or Cmd+Shift+L (Mac)
```

## Package Installation from Different Sources

### From Local Directory

```{r,eval=FALSE}
# Install from local directory
install.packages("path/to/pharmaTools", repos = NULL, type = "source")

# Using devtools
devtools::install_local("path/to/pharmaTools")
```

### From GitHub

```{r,eval=FALSE}
# Install from GitHub
devtools::install_github("username/pharmaTools")

# Install specific branch or tag
devtools::install_github("username/pharmaTools@develop")
devtools::install_github("username/pharmaTools@v0.1.0")

# With vignettes
devtools::install_github("username/pharmaTools", build_vignettes = TRUE)
```

### From GitLab or Bitbucket

```{r,eval=FALSE}
# GitLab
devtools::install_gitlab("username/pharmaTools")

# Bitbucket
devtools::install_bitbucket("username/pharmaTools")
```

## Practical Example: Complete Package Build Workflow

```{r,eval=FALSE}
# Step 1: Document the package
devtools::document()

# Step 2: Run tests
devtools::test()

# Step 3: Check package
devtools::check()

# Step 4: Install locally
devtools::install()

# Step 5: Build package tarball for distribution
devtools::build()

# Step 6: (Optional) Check as CRAN would
rcmdcheck::rcmdcheck(args = c("--as-cran"))
```

# Testing with testthat

## Setting Up testthat

```{r,eval=FALSE}
# Initialize testing infrastructure
usethis::use_testthat()

# This creates:
# - tests/testthat/ directory
# - tests/testthat. R file
```

The structure looks like: 

```
tests/
├── testthat/
│   ├── test-pk-functions.R
│   ├── test-ae-functions.R
│   └── test-utils.R
└── testthat.R
```

## Basic testthat Syntax

### Simple Test Example

```{r,eval=FALSE}
# File: tests/testthat/test-bmi. R

test_that("calculate_bmi works with single values", {
  result <- calculate_bmi(weight = 70, height = 1.75)
  
  expect_equal(result, 22.86, tolerance = 0.01)
  expect_type(result, "double")
  expect_length(result, 1)
})

test_that("calculate_bmi works with vectors", {
  weights <- c(65, 80, 75)
  heights <- c(1.68, 1.82, 1.70)
  
  results <- calculate_bmi(weight = weights, height = heights)
  
  expect_length(results, 3)
  expect_true(all(results > 0))
})

test_that("calculate_bmi handles errors correctly", {
  expect_error(
    calculate_bmi(weight = "70", height = 1.75),
    "must be numeric"
  )
  
  expect_error(
    calculate_bmi(weight = -70, height = 1.75),
    "must be positive"
  )
  
  expect_error(
    calculate_bmi(weight = 70, height = 0),
    "must be positive"
  )
})

test_that("calculate_bmi handles missing values", {
  result <- calculate_bmi(weight = c(70, NA, 80), height = c(1.75, 1.68, 1.82))
  
  expect_length(result, 3)
  expect_true(is.na(result[2]))
  expect_false(is.na(result[1]))
})
```

## Essential testthat Expectations

### Equality and Comparison

```{r,eval=FALSE}
# Exact equality
expect_equal(1 + 1, 2)

# With tolerance for numeric
expect_equal(1.0000001, 1.0, tolerance = 0.001)

# Identical (stricter than equal)
expect_identical(1L, 1L)

# TRUE/FALSE
expect_true(5 > 3)
expect_false(5 < 3)
```

### Type and Class Checks

```{r,eval=FALSE}
# Check type
expect_type(c(1, 2, 3), "double")
expect_type("text", "character")

# Check class (S3)
expect_s3_class(data.frame(), "data.frame")

# Check class (S4)
expect_s4_class(methods::new("MethodDefinition"), "MethodDefinition")

# Check inheritance
expect_is(mtcars, "data.frame")
```

### Length and Dimension

```{r,eval=FALSE}
# Vector length
expect_length(1:5, 5)

# Named object
expect_named(c(a = 1, b = 2), c("a", "b"))

# Data frame dimensions
expect_equal(nrow(mtcars), 32)
expect_equal(ncol(mtcars), 11)
```

### Errors, Warnings, Messages

```{r,eval=FALSE}
# Expect error
expect_error(stop("Error! "))
expect_error(log("text"), "non-numeric")

# Expect warning
expect_warning(log(-1))
expect_warning(as.numeric("text"), "NAs introduced")

# Expect message
expect_message(message("Hello"))

# Expect silent (no errors, warnings, or messages)
expect_silent(1 + 1)
```

### Matching Patterns

```{r,eval=FALSE}
# String matching
expect_match("hello world", "world")
expect_match("test123", "\\d+")  # Regex

# Output matching
expect_output(print("hello"), "hello")
```

# Writing Unit Tests for R Functions

## Testing Pharmacokinetic Functions

```{r,eval=FALSE}
# File: tests/testthat/test-pk-functions.R

# Test data fixture
create_test_pk_data <- function() {
  list(
    time = c(0, 0.5, 1, 2, 4, 8, 12, 24),
    conc = c(0, 85, 100, 90, 70, 45, 28, 10),
    dose = 500
  )
}

test_that("calculate_pk_parameters returns correct structure", {
  test_data <- create_test_pk_data()
  
  result <- calculate_pk_parameters(
    time = test_data$time,
    concentration = test_data$conc,
    dose = test_data$dose
  )
  
  # Check structure
  expect_type(result, "list")
  expect_named(result, c("Cmax", "Tmax", "AUC_0_t", "AUC_0_inf", 
                        "t_half", "lambda_z", "CL_F", "Vd_F"))
  
  # Check that all values are numeric
  expect_true(all(sapply(result[! is.na(result)], is.numeric)))
})

test_that("calculate_pk_parameters calculates Cmax and Tmax correctly", {
  test_data <- create_test_pk_data()
  
  result <- calculate_pk_parameters(
    time = test_data$time,
    concentration = test_data$conc,
    dose = test_data$dose
  )
  
  # Cmax should be maximum concentration
  expect_equal(result$Cmax, 100)
  
  # Tmax should be time of maximum
  expect_equal(result$Tmax, 1)
})

test_that("calculate_pk_parameters calculates AUC correctly", {
  # Simple trapezoidal test case
  time <- c(0, 1, 2)
  conc <- c(0, 10, 0)
  
  result <- calculate_pk_parameters(
    time = time,
    concentration = conc,
    dose = 100
  )
  
  # AUC should be area of triangle = 0.5 * 2 * 10 = 10
  expect_equal(result$AUC_0_t, 10, tolerance = 0.01)
})

test_that("calculate_pk_parameters handles missing data", {
  time <- c(0, 1, NA, 4, 8)
  conc <- c(0, 100, 90, NA, 45)
  
  result <- calculate_pk_parameters(
    time = time,
    concentration = conc,
    dose = 500
  )
  
  # Should still calculate without error
  expect_type(result, "list")
  expect_false(is.na(result$Cmax))
})

test_that("calculate_pk_parameters validates inputs", {
  # Mismatched lengths
  expect_error(
    calculate_pk_parameters(
      time = c(0, 1, 2),
      concentration = c(0, 100),
      dose = 500
    ),
    "same length"
  )
  
  # Negative time
  expect_error(
    calculate_pk_parameters(
      time = c(-1, 0, 1),
      concentration = c(0, 100, 80),
      dose = 500
    ),
    "non-negative"
  )
  
  # Negative concentrations should warn
  expect_warning(
    calculate_pk_parameters(
      time = c(0, 1, 2),
      concentration = c(0, 100, -10),
      dose = 500
    ),
    "Negative concentrations"
  )
})

test_that("calculate_pk_parameters calculates half-life correctly", {
  # Exponential decay:  C = 100 * exp(-0.1 * t)
  # Half-life = ln(2)/0.1 = 6.93 hours
  time <- seq(0, 30, by = 2)
  conc <- 100 * exp(-0.1 * time)
  
  result <- calculate_pk_parameters(
    time = time,
    concentration = conc,
    dose = 1000
  )
  
  expect_equal(result$t_half, 6.93, tolerance = 0.5)
  expect_equal(result$lambda_z, 0.1, tolerance = 0.01)
})
```

## Testing Adverse Event Functions

```{r,eval=FALSE}
# File: tests/testthat/test-ae-functions.R

# Create test dataset
create_test_adae <- function() {
  data.frame(
    USUBJID = c("001", "001", "002", "002", "003", "004"),
    TRTA = c("Placebo", "Placebo", "Drug 10mg", "Drug 10mg", "Drug 20mg", "Drug 20mg"),
    AEDECOD = c("Headache", "Nausea", "Headache", "Fatigue", "Nausea", "Headache"),
    stringsAsFactors = FALSE
  )
}

test_that("summarize_adverse_events returns correct structure", {
  test_data <- create_test_adae()
  
  result <- summarize_adverse_events(
    data = test_data,
    ae_term = "AEDECOD",
    treatment = "TRTA",
    subject_id = "USUBJID"
  )
  
  # Check structure
  expect_s3_class(result, "data.frame")
  expect_true("AEDECOD" %in% names(result))
  expect_true("total_n" %in% names(result))
})

test_that("summarize_adverse_events counts subjects correctly", {
  test_data <- create_test_adae()
  
  result <- summarize_adverse_events(
    data = test_data,
    ae_term = "AEDECOD",
    treatment = "TRTA",
    subject_id = "USUBJID"
  )
  
  # Headache appears in 3 subjects
  headache_row <- result[result$AEDECOD == "Headache", ]
  expect_equal(headache_row$total_n, 3)
})

test_that("summarize_adverse_events validates inputs", {
  test_data <- create_test_adae()
  
  # Missing column
  expect_error(
    summarize_adverse_events(
      data = test_data,
      ae_term = "NONEXISTENT",
      treatment = "TRTA",
      subject_id = "USUBJID"
    ),
    "Missing required columns"
  )
  
  # Not a data frame
  expect_error(
    summarize_adverse_events(
      data = "not a dataframe",
      ae_term = "AEDECOD",
      treatment = "TRTA"
    ),
    "must be a data frame"
  )
})

test_that("summarize_adverse_events filters by minimum percentage", {
  test_data <- create_test_adae()
  
  # Without filter
  result_all <- summarize_adverse_events(
    data = test_data,
    min_pct = 0
  )
  
  # With 50% filter
  result_filtered <- summarize_adverse_events(
    data = test_data,
    min_pct = 50
  )
  
  # Filtered should have fewer rows
  expect_true(nrow(result_filtered) <= nrow(result_all))
})

test_that("summarize_adverse_events sorts correctly", {
  test_data <- create_test_adae()
  
  # Sort by frequency
  result_freq <- summarize_adverse_events(
    data = test_data,
    sort_by = "frequency"
  )
  
  # Sort alphabetically
  result_alpha <- summarize_adverse_events(
    data = test_data,
    sort_by = "alphabetical"
  )
  
  # Check ordering
  expect_true(result_freq$AEDECOD[1] %in% c("Headache", "Nausea"))  # Most common
  expect_equal(result_alpha$AEDECOD[1], "Fatigue")  # Alphabetically first
})
```

## Testing with Mock Data

```{r,eval=FALSE}
# File: tests/testthat/helper-mock-data.R

# Helper functions available to all tests

create_mock_adsl <- function(n = 100, treatments = 3) {
  data.frame(
    USUBJID = sprintf("SUBJ-%03d", 1:n),
    AGE = round(rnorm(n, mean = 55, sd = 12)),
    SEX = sample(c("M", "F"), n, replace = TRUE),
    RACE = sample(c("WHITE", "BLACK", "ASIAN"), n, replace = TRUE),
    TRTA = sample(paste0("TRT", 1:treatments), n, replace = TRUE),
    SAFFL = "Y",
    stringsAsFactors = FALSE
  )
}

create_mock_adae <- function(adsl, ae_per_subject = 2) {
  ae_terms <- c("Headache", "Nausea", "Fatigue", "Dizziness", 
                "Insomnia", "Diarrhea", "Rash")
  
  n_ae <- nrow(adsl) * ae_per_subject
  
  data.frame(
    USUBJID = sample(adsl$USUBJID, n_ae, replace = TRUE),
    AEDECOD = sample(ae_terms, n_ae, replace = TRUE),
    AESEV = sample(c("MILD", "MODERATE", "SEVERE"), n_ae, 
                  replace = TRUE, prob = c(0.6, 0.3, 0.1)),
    AEREL = sample(c("RELATED", "NOT RELATED"), n_ae, 
                  replace = TRUE, prob = c(0.3, 0.7)),
    stringsAsFactors = FALSE
  ) %>%
    dplyr:: left_join(adsl[, c("USUBJID", "TRTA")], by = "USUBJID")
}
```

## Testing with Snapshots

```{r,eval=FALSE}
# File: tests/testthat/test-output-tables.R

test_that("demographic table output is consistent", {
  test_data <- create_mock_adsl(n = 50)
  
  table_output <- create_demographic_table(test_data)
  
  # Snapshot test - saves first run, compares subsequent runs
  expect_snapshot(table_output)
})

# To update snapshots when intentionally changed:
# testthat::snapshot_accept()
```

# Running Tests and Interpreting Results

## Running Tests

### Run All Tests

```{r,eval=FALSE}
# Run all tests in the package
devtools::test()

# Keyboard shortcut: Ctrl+Shift+T (Windows/Linux) or Cmd+Shift+T (Mac)
```

### Run Specific Test Files

```{r,eval=FALSE}
# Run a single test file
testthat::test_file("tests/testthat/test-pk-functions.R")

# Run tests matching a pattern
devtools::test(filter = "pk")  # Runs all test-pk-*. R files
```

### Run Tests with Coverage

```{r,eval= FALSE}
# Check test coverage
covr::package_coverage()

# View coverage report in browser
covr::report()

# Coverage for specific file
covr::file_coverage("R/pk-functions.R", "tests/testthat/test-pk-functions.R")
```

## Interpreting Test Results

### Successful Test Output

```
✓ |  OK F W S | Context
✓ |  12       | BMI calculations
✓ |  15       | Pharmacokinetic parameters
✓ |  18       | Adverse event summaries

══ Results ════════════════════════════════════════
Duration: 2.3 s

[ FAIL 0 | WARN 0 | SKIP 0 | PASS 45 ]
```

### Failed Test Output

```
── Failure:  calculate_pk_parameters calculates Cmax correctly ─────
result$Cmax not equal to 100.
target is NULL, current is numeric

Backtrace:
 1. pharmaTools:: calculate_pk_parameters(...)
    at test-pk-functions.R:45:2

[ FAIL 1 | WARN 0 | SKIP 0 | PASS 44 ]
```

### Skipped Tests

```{r,eval= FALSE}
# Skip tests conditionally
test_that("function works with specific package", {
  skip_if_not_installed("pkgname")
  skip_on_cran()
  skip_on_ci()
  
  # Test code here
})
```

## Continuous Integration

### GitHub Actions Example

```yaml
# .github/workflows/R-CMD-check.yaml

on:
  push:
    branches: [main, develop]
  pull_request: 
    branches: [main, develop]

name: R-CMD-check

jobs:
  R-CMD-check:
    runs-on: ${{ matrix.config.os }}

    strategy:
      fail-fast: false
      matrix: 
        config:
          - {os: windows-latest, r: 'release'}
          - {os: macOS-latest, r: 'release'}
          - {os:  ubuntu-20.04, r: 'release', rspm: "https://packagemanager.rstudio.com/cran/__linux__/focal/latest"}
          - {os: ubuntu-20.04, r: 'devel', rspm: "https://packagemanager.rstudio. com/cran/__linux__/focal/latest"}

    steps:
      - uses: actions/checkout@v2

      - uses: r-lib/actions/setup-r@v2
        with:
          r-version: ${{ matrix.config.r }}

      - uses: r-lib/actions/setup-pandoc@v2

      - name: Query dependencies
        run: |
          install.packages('remotes')
          saveRDS(remotes:: dev_package_deps(dependencies = TRUE), ".github/depends.Rds", version = 2)
        shell: Rscript {0}

      - name: Install dependencies
        run: |
          remotes::install_deps(dependencies = TRUE)
          remotes::install_cran("rcmdcheck")
        shell: Rscript {0}

      - name: Check
        run:  |
          rcmdcheck::rcmdcheck(args = c("--no-manual", "--as-cran"), error_on = "warning", check_dir = "check")
        shell: Rscript {0}
```

## Best Practices for Testing

### 1. Test Coverage Goals

```{r,eval= FALSE}
# Aim for high coverage
# - Critical functions: 100% coverage
# - User-facing functions: > 95% coverage
# - Utility functions: > 80% coverage
# - Overall package: > 90% coverage

# Check coverage
cov <- covr::package_coverage()
print(cov)
covr::report(cov)
```

### 2. Test Organization

```
tests/testthat/
├── helper-mock-data.R        # Shared test data generators
├── helper-utilities.R         # Shared test utilities
├── setup. R                    # Run once before all tests
├── test-pk-functions.R        # PK function tests
├── test-ae-functions.R        # AE function tests
├── test-demographics.R        # Demographics tests
└── test-utils.R               # Utility function tests
```

### 3. Test Naming Conventions

```{r,eval= FALSE}
# Good test names
test_that("calculate_bmi returns correct values for normal input", {})
test_that("calculate_bmi handles missing values appropriately", {})
test_that("calculate_bmi throws error for negative weights", {})

# Bad test names
test_that("test 1", {})
test_that("bmi", {})
test_that("works", {})
```

### 4. Testing Edge Cases

```{r,eval= FALSE}
test_that("function handles edge cases", {
  # Empty input
  expect_error(my_function(c()))
  
  # Single value
  expect_equal(my_function(1), expected_value)
  
  # Very large values
  expect_true(is.finite(my_function(1e10)))
  
  # Very small values
  expect_true(is.finite(my_function(1e-10)))
  
  # All missing
  expect_true(all(is.na(my_function(c(NA, NA, NA)))))
  
  # Mixed missing and valid
  result <- my_function(c(1, NA, 3))
  expect_length(result, 3)
  expect_true(is.na(result[2]))
})
```

# Complete Package Development Workflow

## Example: Creating a Complete Pharmaceutical Package

Let's walk through creating a complete package called `clinicalTrialTools`:

```{r,eval= FALSE}
# Step 1: Create package structure
usethis::create_package("~/projects/clinicalTrialTools")

# Step 2: Set up version control
usethis::use_git()
usethis::use_github()  # If using GitHub

# Step 3: Add license
usethis::use_mit_license("Your Name")

# Step 4: Set up testing
usethis::use_testthat()

# Step 5: Set up continuous integration
usethis::use_github_action("check-standard")
usethis::use_github_action("test-coverage")

# Step 6: Add dependencies
usethis::use_package("dplyr", type = "Imports")
usethis::use_package("tidyr", type = "Imports")
usethis::use_package("rlang", type = "Imports")
usethis::use_package("haven", type = "Suggests")

# Step 7: Create first function
usethis::use_r("demographics")

# Step 8: Document package
usethis::use_package_doc()
usethis::use_readme_rmd()
usethis::use_news_md()

# Step 9: Add data
usethis::use_data_raw("adsl")

# Step 10: Create vignettes
usethis::use_vignette("introduction")
usethis::use_vignette("demographics-analysis")

# Step 11: Set up pkgdown website
usethis::use_pkgdown()

# Development cycle: 
# 1. Write function in R/
# 2. Document with roxygen2
# 3. Load with devtools::load_all()
# 4. Write tests in tests/testthat/
# 5. Run tests with devtools::test()
# 6. Check with devtools::check()
# 7. Commit changes to Git
# 8. Repeat

# Before release:
# 1. Update NEWS.md
# 2. Update version in DESCRIPTION
# 3. Run devtools::check()
# 4. Build vignettes
# 5. Build pkgdown site
# 6. Create Git tag
# 7. Push to GitHub
```

## Package Release Checklist

```{r, eval = FALSE}
# 1. Update version number
usethis::use_version()

# 2. Update NEWS.md
usethis::use_news_md()

# 3. Check package
devtools::check()

# 4. Check as CRAN would
rcmdcheck::rcmdcheck(args = "--as-cran")

# 5. Check on multiple R versions
devtools::check_win_devel()  # Windows
devtools::check_mac_release()  # macOS

# 6. Check reverse dependencies (if any)
revdepcheck::revdep_check()

# 7. Update documentation
devtools::document()

# 8. Build README
rmarkdown::render("README. Rmd")

# 9. Build vignettes
devtools::build_vignettes()

# 10. Build pkgdown site
pkgdown::build_site()

# 11. Spell check
spelling::spell_check_package()

# 12. Submit to CRAN (if applicable)
devtools::release()
```

# Summary

Creating R packages is essential for pharmaceutical programming: 

## Key Takeaways

1. **Package Structure**
   - DESCRIPTION file defines package metadata
   - NAMESPACE controls function visibility (managed by roxygen2)
   - R/ directory contains all R code
   - tests/ directory contains unit tests

2. **Documentation with roxygen2**
   - Use `#'` comments above functions
   - Key tags: `@param`, `@return`, `@examples`, `@export`
   - Generate with `devtools::document()`

3. **Building and Installing**
   - `devtools::load_all()` for development
   - `devtools::check()` validates package
   - `devtools::install()` installs locally
   - `devtools::build()` creates distribution files

4. **Testing with testthat**
   - `usethis::use_testthat()` sets up testing
   - Write tests in tests/testthat/
   - Use `expect_*()` functions for assertions
   - Run with `devtools::test()`

5. **Best Practices**
   - Write comprehensive tests (aim for >90% coverage)
   - Document all exported functions
   - Use meaningful function and parameter names
   - Validate inputs thoroughly
   - Include examples in documentation
   - Version control with Git
   - Use continuous integration (GitHub Actions)

## Resources

- **Books**
  - [R Packages (2nd ed.)](https://r-pkgs.org/) by Hadley Wickham and Jennifer Bryan
  - [Mastering Software Development in R](https://bookdown.org/rdpeng/RProgDA/) by Roger Peng et al. 

- **Websites**
  - [CRAN Repository Policy](https://cran.r-project.org/web/packages/policies.html)
  - [rOpenSci Packages](https://devguide.ropensci. org/)
  - [Pharmaverse](https://pharmaverse.org/) - Pharma-specific R packages

- **Tools**
  - {devtools} - Package development tools
  - {usethis} - Workflow automation
  - {roxygen2} - Documentation
  - {testthat} - Testing framework
  - {pkgdown} - Package websites
  - {covr} - Test coverage
