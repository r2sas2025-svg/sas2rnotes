[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R tutorial: Beginner to Expert",
    "section": "",
    "text": "About",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "index.html#course-overview",
    "href": "index.html#course-overview",
    "title": "R tutorial: Beginner to Expert",
    "section": "Course Overview",
    "text": "Course Overview\nThis comprehensive course is designed specifically for SAS programmers who want to learn R programming. We’ll leverage your existing knowledge of data manipulation, statistical analysis, and programming concepts to help you become proficient in R.",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "index.html#learning-objectives",
    "href": "index.html#learning-objectives",
    "title": "R tutorial: Beginner to Expert",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nBy the end of this course, you will be able to:\n\nUnderstand R fundamentals: Master R syntax, data types, and programming concepts\nData manipulation: Perform complex data transformations using dplyr and base R\nStatistical analysis: Apply statistical methods and create models in R\nData visualization: Create compelling visualizations using ggplot2\nReporting: Generate dynamic reports with R Markdown and Quarto\nBridge knowledge: Map your SAS skills to equivalent R functions and workflows\nBest practices: Write clean, efficient, and reproducible R code",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "index.html#course-structure",
    "href": "index.html#course-structure",
    "title": "R tutorial: Beginner to Expert",
    "section": "Course Structure",
    "text": "Course Structure\n\nModule 1: R Fundamentals for SAS Users\n\nGetting Started\n\nR and RStudio installation and setup\nUnderstanding the R environment vs SAS environment\nPackage management\n\nBasic R Syntax\n\nR syntax compared to SAS syntax\nVariables and assignment operators\nData types and structures\nFunctions and help system\n\n\n\n\nModule 2: Data Import and Export\n\nCSV, Excel and text files (readr, readxl packages)\nSAS dataset import (haven package) and export xpt files\nother formats (JSON, XML)\n\n\n\nModule 3: Data Manipulation - dplyr\n\nCore dplyr Functions\n\nselect() vs KEEP/DROP statements\nfilter() vs WHERE clause\nmutate() vs assignment statements\nsummarise() vs PROC MEANS\ngroup_by() vs BY statement\n\nAdvanced Data Manipulation\n\nJoins equivalent to PROC SQL joins\n\nReshaping data (tidyr vs PROC TRANSPOSE)\nString manipulation (stringr vs SAS string functions)\n\n\n\n\nModule 4: Creation of ADSL dataset\n\nADSL and ADVS Dataset Creation\n\nCreating analysis variables\nHandling missing data and derivations\ncreating ADSL xpt dataset\n\n\n\n\nModule 5: Statistical Analysis\n\nDescriptive Statistics\n\nSummary statistics (equivalent to PROC UNIVARIATE)\nFrequency tables (equivalent to PROC FREQ)\nCross-tabulations and chi-square tests\ncreation of tables like DM and AE outputs\n\nStatistical Modeling basics\n\nLinear regression (equivalent to PROC REG)\nLogistic regression (equivalent to PROC LOGISTIC)\nANOVA (equivalent to PROC ANOVA)\nMixed models and advanced techniques\n\n\n\n\nModule 6: Package Develpment and testing\n\nCreating R Packages\n\nPackage structure and essential files\nDocumenting functions with roxygen2\nBuilding and installing packages\n\nTesting with testthat\n\nWriting unit tests for R functions\nRunning tests and interpreting results\n\n\n\n\nModule 7: Data Visualization\n\nBase R Graphics\n\nBasic plots and customization\nComparison with SAS/GRAPH\n\nggplot2 - Grammar of Graphics\n\nUnderstanding the layered approach\nCreating publication-ready plots\nAdvanced visualization techniques\n\n\n\n\nModule 8: Reporting and Documentation\n\nR Markdown and Quarto\n\nCreating dynamic reports (equivalent to ODS output)\nIntegrating code, results, and narrative\nOutput formats: HTML, PDF, Word\n\nReproducible Research\n\nProject organization\nVersion control with Git\nBest practices for code documentation",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "index.html#sas-to-r-translation-guide",
    "href": "index.html#sas-to-r-translation-guide",
    "title": "R tutorial: Beginner to Expert",
    "section": "SAS to R Translation Guide",
    "text": "SAS to R Translation Guide\n\n\n\nSAS Concept\nR Equivalent\nPackage\n\n\n\n\nDATA step\ndplyr::mutate()\ndplyr\n\n\nPROC SQL\ndplyr verbs\ndplyr\n\n\nPROC MEANS\ndplyr::summarise()\ndplyr\n\n\nPROC FREQ\ntable(), xtabs()\nbase R\n\n\nPROC REG\nlm()\nbase R\n\n\nPROC LOGISTIC\nglm()\nbase R\n\n\nPROC TRANSPOSE\ntidyr::pivot_*()\ntidyr\n\n\nODS OUTPUT\nR Markdown/Quarto\nrmarkdown/quarto",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "R tutorial: Beginner to Expert",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nSAS Experience: Familiarity with SAS programming, data steps, and procedures\nStatistical Knowledge: Basic understanding of statistical concepts\nProgramming Basics: Understanding of programming logic and data structures",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "index.html#course-format",
    "href": "index.html#course-format",
    "title": "R tutorial: Beginner to Expert",
    "section": "Course Format",
    "text": "Course Format\n\nInteractive Learning: Hands-on exercises with real datasets\nComparative Examples: Side-by-side SAS and R code comparisons\nPractical Projects: Real-world scenarios mimicking typical SAS workflows\nReference Materials: Quick reference guides and cheat sheets",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "R tutorial: Beginner to Expert",
    "section": "Getting Started",
    "text": "Getting Started\n\nRequired Software\n\nR (version 4.3+): Download from CRAN\nRStudio: Download from Posit\nEssential Packages: We’ll install these as needed\n\n\n   install.packages(c(\"tidyverse\", \"haven\", \"readxl\", \"rmarkdown\"))\n\n\nTip: If you don’t have sample SDTM/ADaM data yet, the chapters generate small synthetic data as a fallback so everything runs end-to-end. ## contact For questions or feedback, reach out to r2sas2025@gmail.com",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "datatype_structure.html",
    "href": "datatype_structure.html",
    "title": "1  R Fundamentals for SAS Users",
    "section": "",
    "text": "2 Introduction\nThis guide is designed for SAS users transitioning to R. We’ll cover fundamental R concepts by comparing them to familiar SAS constructs, providing comprehensive coverage of each topic.",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#prerequisites",
    "href": "datatype_structure.html#prerequisites",
    "title": "1  R Fundamentals for SAS Users",
    "section": "2.1 Prerequisites",
    "text": "2.1 Prerequisites",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#basic-code-structure-and-comments",
    "href": "datatype_structure.html#basic-code-structure-and-comments",
    "title": "1  R Fundamentals for SAS Users",
    "section": "3.1 Basic Code Structure and Comments",
    "text": "3.1 Basic Code Structure and Comments\n\nUnderstanding how R code is structured compared to SAS is fundamental to making the transition.\n\n:: {.panel-tabset}",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#sas",
    "href": "datatype_structure.html#sas",
    "title": "1  R Fundamentals for SAS Users",
    "section": "3.2 SAS",
    "text": "3.2 SAS\n/* Multi-line comments in SAS \n   can span multiple lines */\n* Single line comment with asterisk;\n\n/* Statements must end with semicolons */\nDATA mydata;\n    SET olddata;\n    new_var = old_var * 2;\nRUN;\n\n/* Procedures need RUN statements */\nPROC PRINT DATA=mydata;\nRUN;\n\n/* Case insensitive - these are all the same */\ndata test;\nDATA test;\nData test;",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#r",
    "href": "datatype_structure.html#r",
    "title": "1  R Fundamentals for SAS Users",
    "section": "3.3 R",
    "text": "3.3 R\n\n# Single line comments use hash symbol\n# There are no multi-line comments in base R\n# (though RStudio supports Ctrl+Shift+C for multiple lines)\n\n# Semicolons are optional but allowed\nnew_var &lt;- old_var * 2  # No semicolon needed\nnew_var &lt;- old_var * 2; # Semicolon allowed\n\n# No RUN statements required - code executes immediately\nprint(mydata)\n\n# R is CASE SENSITIVE - these are different variables\ndata &lt;- 1\nData &lt;- 2\nDATA &lt;- 3\n\n:::\n\n3.3.1 Key Syntax Differences\n\n\n\n\n\n\n\n\n\nAspect\nSAS\nR\nNotes\n\n\n\n\nComment\n/* */ or *;\n#\nR comments run to end of line only\n\n\nStatement terminator\n; required\n; optional\nMost R code omits semicolons\n\n\nCase sensitivity\nNot case-sensitive\nCase-sensitive\nMajor difference!\n\n\nAssignment\n=\n&lt;- or =\n&lt;- is preferred in R\n\n\nBlock execution\nRUN; required\nAutomatic\nCode executes line by line\n\n\nLine continuation\nAutomatic\nAutomatic with open brackets\n\n\n\n\n\n\n3.3.2 Demonstrating Case Sensitivity\n\n# In R, these are THREE DIFFERENT variables\nVariable &lt;- 10\nvariable &lt;- 20\nVARIABLE &lt;- 30\n\nprint(Variable)  # Returns 10\n\n[1] 10\n\nprint(variable)  # Returns 20\n\n[1] 20\n\nprint(VARIABLE)  # Returns 30\n\n[1] 30\n\n# This would cause confusion in SAS but works in R\nmydata &lt;- data.frame(x = 1:5)\nMyData &lt;- data.frame(x = 6:10)\nMYDATA &lt;- data.frame(x = 11:15)\n\n# Each is a separate object\nnrow(mydata)  # 5\n\n[1] 5\n\nnrow(MyData)  # 5\n\n[1] 5\n\nnrow(MYDATA)  # 5\n\n[1] 5",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#procedural-vs-functional-programming-paradigm",
    "href": "datatype_structure.html#procedural-vs-functional-programming-paradigm",
    "title": "1  R Fundamentals for SAS Users",
    "section": "3.4 Procedural vs Functional Programming Paradigm",
    "text": "3.4 Procedural vs Functional Programming Paradigm\nSAS and R have fundamentally different approaches to data manipulation and analysis.\n\n3.4.1 SAS: Step-by-Step Procedures\n/* SAS uses distinct procedures with explicit steps */\n\n/* Step 1: Sort data */\nPROC SORT DATA=mydata OUT=sorted_data;\n    BY age;\nRUN;\n\n/* Step 2: Calculate statistics */\nPROC MEANS DATA=sorted_data MEAN STD;\n    VAR income;\n    CLASS gender;\n    OUTPUT OUT=summary_stats MEAN=avg_income STD=sd_income;\nRUN;\n\n/* Step 3: Print results */\nPROC PRINT DATA=summary_stats;\nRUN;\n\n\n3.4.2 R: Multiple Functional Approaches\n\n# Approach 1: Base R - function chaining\nsorted_data &lt;- mydata[order(mydata$age), ]\nsummary_stats &lt;- aggregate(income ~ gender, data = sorted_data, \n                          FUN = function(x) c(mean = mean(x), sd = sd(x)))\nprint(summary_stats)\n\n# Approach 2: tidyverse - pipe operator (most similar to thinking in steps)\nsummary_stats &lt;- mydata %&gt;%\n    arrange(age) %&gt;%\n    group_by(gender) %&gt;%\n    summarise(\n        avg_income = mean(income, na.rm = TRUE),\n        sd_income = sd(income, na.rm = TRUE)\n    )\n\nprint(summary_stats)\n\n# Approach 3: data.table - high performance\nlibrary(data.table)\ndt &lt;- as.data.table(mydata)\nsummary_stats &lt;- dt[order(age)][, .(avg_income = mean(income), \n                                     sd_income = sd(income)), \n                                 by = gender]\nprint(summary_stats)\n\n\n\n3.4.3 Understanding the Pipe Operator (%&gt;% and |&gt;)\nThe pipe operator makes R code read more like SAS procedures:\n\n# Create sample data\nemployees &lt;- data.frame(\n    name = c(\"John\", \"Jane\", \"Bob\", \"Alice\", \"Charlie\", \"Diana\"),\n    department = c(\"Sales\", \"IT\", \"IT\", \"Sales\", \"HR\", \"Sales\"),\n    salary = c(50000, 75000, 68000, 52000, 48000, 55000),\n    years = c(2, 5, 3, 1, 4, 3)\n)\n\n# Without pipes (nested functions - hard to read)\nresult1 &lt;- head(arrange(filter(employees, department == \"Sales\"), desc(salary)), 3)\n\n# With pipes (reads left to right, top to bottom)\nresult2 &lt;- employees %&gt;%\n    filter(department == \"Sales\") %&gt;%\n    arrange(desc(salary)) %&gt;%\n    head(3)\n\nprint(result2)\n\n   name department salary years\n1 Diana      Sales  55000     3\n2 Alice      Sales  52000     1\n3  John      Sales  50000     2\n\n# Native pipe |&gt; (R 4.1+) - similar but slightly different\nresult3 &lt;- employees |&gt;\n    filter(department == \"Sales\") |&gt;\n    arrange(desc(salary)) |&gt;\n    head(3)\n\nprint(result3)\n\n   name department salary years\n1 Diana      Sales  55000     3\n2 Alice      Sales  52000     1\n3  John      Sales  50000     2",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#execution-and-evaluation-models",
    "href": "datatype_structure.html#execution-and-evaluation-models",
    "title": "1  R Fundamentals for SAS Users",
    "section": "3.5 Execution and Evaluation Models",
    "text": "3.5 Execution and Evaluation Models\nUnderstanding how R evaluates code differently from SAS helps avoid common pitfalls.\n\n3.5.1 Sequential vs Expression-Based Execution\nSAS: Executes in clearly defined DATA and PROC steps with explicit boundaries\n/* SAS processes entire DATA step before moving to next step */\nDATA step1;\n    SET input_data;\n    x = 10;\nRUN;  /* Everything above completes before proceeding */\n\nDATA step2;\n    SET step1;\n    y = x + 5;  /* x is available because step1 completed */\nRUN;\nR: Expression-based evaluation, code executes immediately\n\n# R executes line by line\nx &lt;- 10            # Executes immediately\ny &lt;- x + 5         # Can use x immediately\nz &lt;- x + y         # Can use both x and y\n\nprint(paste(\"x:\", x, \"y:\", y, \"z:\", z))\n\n[1] \"x: 10 y: 15 z: 25\"\n\n# Functions execute when called\nmy_calculation &lt;- function() {\n    a &lt;- 100\n    b &lt;- 200\n    return(a + b)\n}\n\n# Function is defined but not executed yet\nresult &lt;- my_calculation()  # Now it executes\nprint(result)\n\n[1] 300\n\n\n\n\n3.5.2 Lazy Evaluation in R\nR uses “lazy evaluation” - function arguments are only evaluated when actually used:\n\n# Demonstrating lazy evaluation\nmy_function &lt;- function(x, y, z) {\n    # If we return early, unused arguments never get evaluated\n    if (x &gt; 0) {\n        return(x * 2)\n    }\n    # y and z are never evaluated if x &gt; 0\n    return(y + z)\n}\n\n# This works even though second and third arguments would error\nresult &lt;- my_function(5, stop(\"Error in y!\"), stop(\"Error in z!\"))\nprint(result)  # Returns 10, no errors\n\n[1] 10\n\n# But this would cause an error\n# result &lt;- my_function(-1, stop(\"Error in y!\"), 10)  # ERROR!\n\n\n\n3.5.3 Vectorized Operations\nR operates on entire vectors at once (unlike SAS’s row-by-row processing):\n\n# Create vectors\nvector1 &lt;- c(1, 2, 3, 4, 5)\nvector2 &lt;- c(10, 20, 30, 40, 50)\n\n# Vectorized operation - all elements at once\nresult &lt;- vector1 + vector2\nprint(result)  # 11 22 33 44 55\n\n[1] 11 22 33 44 55\n\n# Comparison to SAS approach\n# In SAS, you'd typically process row by row: \n# DATA result;\n#     SET input;\n#     new_value = value1 + value2;\n# RUN;\n\n# In R, you can also do row-wise operations on data frames\ndf &lt;- data.frame(value1 = vector1, value2 = vector2)\ndf$result &lt;- df$value1 + df$value2\nprint(df)\n\n  value1 value2 result\n1      1     10     11\n2      2     20     22\n3      3     30     33\n4      4     40     44\n5      5     50     55\n\n\n\n\n3.5.4 Recycling Rules\nR automatically “recycles” shorter vectors to match longer ones:\n\n# Vector recycling\nshort_vec &lt;- c(1, 2)\nlong_vec &lt;- c(10, 20, 30, 40, 50, 60)\n\n# short_vec is recycled:  1, 2, 1, 2, 1, 2\nresult &lt;- short_vec + long_vec\nprint(result)  # 11 22 31 42 51 62\n\n[1] 11 22 31 42 51 62\n\n# Warning when lengths don't divide evenly\nvec1 &lt;- c(1, 2, 3)\nvec2 &lt;- c(10, 20, 30, 40, 50)\n# result &lt;- vec1 + vec2  # Would give warning\n\n# Practical use:  add constant to all elements\nvalues &lt;- c(100, 200, 300, 400)\nvalues_plus_10 &lt;- values + 10  # 10 is recycled\nprint(values_plus_10)\n\n[1] 110 210 310 410",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#creating-and-assigning-variables",
    "href": "datatype_structure.html#creating-and-assigning-variables",
    "title": "1  R Fundamentals for SAS Users",
    "section": "4.1 Creating and Assigning Variables",
    "text": "4.1 Creating and Assigning Variables\nUnderstanding variable assignment is crucial for writing effective R code.\n\n4.1.1 Three Assignment Operators\n\n# Left assignment with &lt;- (RECOMMENDED)\nx &lt;- 10\npatient_age &lt;- 45\ndepartment_name &lt;- \"Cardiology\"\n\n# Left assignment with = (works but not preferred for variables)\ny = 20\n# Use = for function arguments:  mean(x, na.rm = TRUE)\n\n# Right assignment with -&gt; (rarely used, but valid)\n30 -&gt; z\n\n# All three created variables\nprint(paste(\"x =\", x, \"| y =\", y, \"| z =\", z))\n\n# Why &lt;- is preferred: \n# 1. Clearly distinguishes assignment from function arguments\n# 2. Consistent with R conventions and style guides\n# 3. Can be read as \"gets\" or \"assign to\"\n\n# Example of clarity with &lt;-\nmy_data &lt;- read.csv(\"file.csv\", header = TRUE)  # Clear distinction\n# vs\n# my_data = read.csv(\"file.csv\", header = TRUE)  # Less clear\n\n\n\n4.1.2 Chaining Assignments\n\n# Multiple assignments in one line\na &lt;- b &lt;- c &lt;- 100\nprint(paste(\"a =\", a, \"| b =\", b, \"| c =\", c))\n\n# Assignment with computation\nresult &lt;- (x &lt;- 5) + (y &lt;- 10)\nprint(paste(\"x =\", x, \"| y =\", y, \"| result =\", result))\n\n# Practical example: assign and use\ndata_subset &lt;- subset(employees, salary &gt; (threshold &lt;- 50000))\nprint(paste(\"Threshold used:\", threshold))\nprint(data_subset)\n\n\n\n4.1.3 Variable Naming Rules and Conventions\n\n# VALID variable names\nvalid_name &lt;- 1\nvalid.name &lt;- 2           # Dots allowed (unlike most languages)\nvalidName &lt;- 3            # camelCase\nvalid_name_123 &lt;- 4       # Numbers allowed (but not at start)\n.hidden_var &lt;- 5          # Starting with dot (hidden from ls())\n\n# Common naming conventions\nsnake_case_variable &lt;- \"preferred in R\"\ncamelCaseVariable &lt;- \"common in some R code\"\ndot.separated.name &lt;- \"traditional R style\"\nPascalCase &lt;- \"typically for functions/classes\"\n\n# INVALID variable names (will cause errors)\n# 123invalid &lt;- 5          # ERROR:  Cannot start with number\n# invalid-name &lt;- 6        # ERROR:  Hyphens not allowed (minus sign)\n# _invalid &lt;- 7            # ERROR: Cannot start with underscore\n# my variable &lt;- 8         # ERROR:  Spaces not allowed\n\n# Reserved words cannot be used as variable names\nreserved_words &lt;- c(\"if\", \"else\", \"repeat\", \"while\", \"function\", \n                    \"for\", \"in\", \"next\", \"break\", \"TRUE\", \"FALSE\", \n                    \"NULL\", \"Inf\", \"NaN\", \"NA\")\nprint(reserved_words)\n\n [1] \"if\"       \"else\"     \"repeat\"   \"while\"    \"function\" \"for\"     \n [7] \"in\"       \"next\"     \"break\"    \"TRUE\"     \"FALSE\"    \"NULL\"    \n[13] \"Inf\"      \"NaN\"      \"NA\"      \n\n# if &lt;- 10  # ERROR: 'if' is reserved\n# BUT you can use them with backticks (not recommended)\n`if` &lt;- 10\nprint(`if`)\n\n[1] 10\n\n\n\n\n4.1.4 Checking and Removing Variables\n\n# Create some variables\nvar1 &lt;- 100\nvar2 &lt;- 200\nvar3 &lt;- 300\n\n# List all variables in environment\ncurrent_vars &lt;- ls()\nprint(current_vars)\n\n [1] \"camelCaseVariable\"   \"df\"                  \"dot.separated.name\" \n [4] \"employees\"           \"if\"                  \"long_vec\"           \n [7] \"my_calculation\"      \"my_function\"         \"mydata\"             \n[10] \"MyData\"              \"MYDATA\"              \"PascalCase\"         \n[13] \"required_packages\"   \"reserved_words\"      \"result\"             \n[16] \"result1\"             \"result2\"             \"result3\"            \n[19] \"short_vec\"           \"snake_case_variable\" \"valid_name\"         \n[22] \"valid_name_123\"      \"valid.name\"          \"validName\"          \n[25] \"values\"              \"values_plus_10\"      \"var1\"               \n[28] \"var2\"                \"var3\"                \"variable\"           \n[31] \"Variable\"            \"VARIABLE\"            \"vec1\"               \n[34] \"vec2\"                \"vector1\"             \"vector2\"            \n[37] \"x\"                   \"y\"                   \"z\"                  \n\n# Check if variable exists\nexists(\"var1\")  # TRUE\n\n[1] TRUE\n\nexists(\"var999\")  # FALSE\n\n[1] FALSE\n\n# Remove specific variables\nrm(var3)\nexists(\"var3\")  # FALSE\n\n[1] FALSE\n\n# Remove multiple variables\nrm(var1, var2)\n\n# Remove all variables (use with caution!)\n# rm(list = ls())",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#variable-scope-and-environments",
    "href": "datatype_structure.html#variable-scope-and-environments",
    "title": "1  R Fundamentals for SAS Users",
    "section": "4.2 Variable Scope and Environments",
    "text": "4.2 Variable Scope and Environments\nUnderstanding scope is crucial for writing functions and avoiding bugs.\n\n4.2.1 Local vs Global Scope\n\n# Global variable (available everywhere)\nglobal_var &lt;- 100\n\n# Function with local variables\nmy_function &lt;- function() {\n    # Local variable (only exists inside function)\n    local_var &lt;- 200\n    \n    # Can read global variables\n    print(paste(\"Inside function, global_var:\", global_var))\n    print(paste(\"Inside function, local_var:\", local_var))\n    \n    # Return something\n    return(local_var * 2)\n}\n\n# Call function\nresult &lt;- my_function()\n\n[1] \"Inside function, global_var: 100\"\n[1] \"Inside function, local_var: 200\"\n\nprint(paste(\"Function returned:\", result))\n\n[1] \"Function returned: 400\"\n\n# local_var doesn't exist outside function\nprint(paste(\"Outside function, global_var:\", global_var))\n\n[1] \"Outside function, global_var: 100\"\n\n# print(local_var)  # ERROR: object 'local_var' not found\n\n\n\n4.2.2 Modifying Global Variables from Functions\n\n# Global variable\ncounter &lt;- 0\n\n# Function that modifies local copy (default behavior)\nincrement_local &lt;- function() {\n    counter &lt;- counter + 1  # Creates local 'counter'\n    print(paste(\"Inside increment_local:\", counter))\n}\n\nincrement_local()\n\n[1] \"Inside increment_local: 1\"\n\nprint(paste(\"Global counter after increment_local:\", counter))  # Still 0! \n\n[1] \"Global counter after increment_local: 0\"\n\n# Function that modifies global variable (use &lt;&lt;- or assign)\nincrement_global &lt;- function() {\n    counter &lt;&lt;- counter + 1  # Modifies global 'counter'\n    print(paste(\"Inside increment_global:\", counter))\n}\n\nincrement_global()\n\n[1] \"Inside increment_global: 1\"\n\nprint(paste(\"Global counter after increment_global:\", counter))  # Now 1! \n\n[1] \"Global counter after increment_global: 1\"\n\nincrement_global()\n\n[1] \"Inside increment_global: 2\"\n\nprint(paste(\"Global counter after second call:\", counter))  # Now 2!\n\n[1] \"Global counter after second call: 2\"\n\n\n\n\n4.2.3 Understanding &lt;&lt;- Super Assignment\nsuper assignment operator &lt;&lt;- allows modification of variables in parent environments.\n\n# &lt;&lt;- searches parent environments until it finds the variable\nouter_function &lt;- function() {\n    x &lt;- 10  # Local to outer_function\n    \n    inner_function &lt;- function() {\n        x &lt;&lt;- x + 5  # Modifies x in outer_function's environment\n        print(paste(\"Inside inner_function, x:\", x))\n    }\n    \n    print(paste(\"Before inner_function, x:\", x))\n    inner_function()\n    print(paste(\"After inner_function, x:\", x))\n}\n\nouter_function()\n\n[1] \"Before inner_function, x: 10\"\n[1] \"Inside inner_function, x: 15\"\n[1] \"After inner_function, x: 15\"\n\n# Use cases for &lt;&lt;-: \n# 1. Counters and state in function factories\n# 2. Caching/memoization\n# 3. Building interactive applications\n# WARNING: Use sparingly, can make code hard to understand\n\n\n\n4.2.4 Function Factories and Closures\n\n# Creating a function that returns a function\ncreate_counter &lt;- function() {\n    count &lt;- 0  # This variable persists across calls\n    \n    function() {\n        count &lt;&lt;- count + 1\n        return(count)\n    }\n}\n\n# Create two independent counters\ncounter1 &lt;- create_counter()\ncounter2 &lt;- create_counter()\n\n# Each maintains its own state\nprint(counter1())  # 1\n\n[1] 1\n\nprint(counter1())  # 2\n\n[1] 2\n\nprint(counter1())  # 3\n\n[1] 3\n\nprint(counter2())  # 1\n\n[1] 1\n\nprint(counter2())  # 2\n\n[1] 2\n\n# Practical example: create functions with specific parameters\ncreate_multiplier &lt;- function(factor) {\n    function(x) {\n        return(x * factor)\n    }\n}\n\ntimes_2 &lt;- create_multiplier(2)\ntimes_10 &lt;- create_multiplier(10)\n\nprint(times_2(5))   # 10\n\n[1] 10\n\nprint(times_10(5))  # 50\n\n[1] 50\n\n\n\n\n4.2.5 Working with Environments Explicitly\nthe default environment is the global environment, but you can use the new.env() function to create and manipulate environments directly.\n\n# Create new environment\nmy_env &lt;- new.env()\n\n# Assign variables to environment\nmy_env$var1 &lt;- 100\nmy_env$var2 &lt;- 200\n\n# Access environment variables\nprint(my_env$var1)\n\n[1] 100\n\n# List variables in environment\nls(my_env)\n\n[1] \"var1\" \"var2\"\n\n# Environments are passed by reference (not copied)\nmodify_env &lt;- function(env) {\n    env$var1 &lt;- 999\n    env$new_var &lt;- 777\n}\n\nmodify_env(my_env)\nprint(my_env$var1)     # 999 (modified!)\n\n[1] 999\n\nprint(my_env$new_var)  # 777 (added!)\n\n[1] 777\n\n# This is different from regular objects which are copied",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#copy-on-modify-behavior",
    "href": "datatype_structure.html#copy-on-modify-behavior",
    "title": "1  R Fundamentals for SAS Users",
    "section": "4.3 Copy-on-Modify Behavior",
    "text": "4.3 Copy-on-Modify Behavior\nR’s copy-on-modify system is important for understanding performance and memory usage.\n\n4.3.1 Default Copy-on-Modify\n\n# Create original vector\noriginal &lt;- c(1, 2, 3, 4, 5)\n\n# Assign to new variable (no copy yet!)\ncopy_var &lt;- original\n\n# Modify copy_var (NOW a copy is made)\ncopy_var[1] &lt;- 999\n\n# Original is unchanged\nprint(original)   # 1 2 3 4 5\n\n[1] 1 2 3 4 5\n\nprint(copy_var)   # 999 2 3 4 5\n\n[1] 999   2   3   4   5\n\n# Same with data frames\noriginal_df &lt;- data.frame(x = 1:5, y = 6:10)\ncopy_df &lt;- original_df\ncopy_df$x[1] &lt;- 999\n\nprint(original_df$x)  # 1 2 3 4 5 (unchanged)\n\n[1] 1 2 3 4 5\n\nprint(copy_df$x)      # 999 2 3 4 5 (modified)\n\n[1] 999   2   3   4   5\n\n\n\n\n4.3.2 Implications for Function Arguments\n\n# Functions receive copies (so modifications don't affect original)\nmodify_vector &lt;- function(vec) {\n    vec[1] &lt;- 999\n    print(paste(\"Inside function:\", paste(vec, collapse = \" \")))\n    return(vec)\n}\n\nmy_vector &lt;- c(1, 2, 3, 4, 5)\nresult &lt;- modify_vector(my_vector)\n\n[1] \"Inside function: 999 2 3 4 5\"\n\nprint(paste(\"Original vector:\", paste(my_vector, collapse = \" \")))  # Unchanged\n\n[1] \"Original vector: 1 2 3 4 5\"\n\nprint(paste(\"Returned vector:\", paste(result, collapse = \" \")))     # Modified\n\n[1] \"Returned vector: 999 2 3 4 5\"\n\n\n\n\n4.3.3 Using Environments for True Reference Behavior\nWhen you need pass-by-reference behavior (like SAS datasets that get modified):\n\n# Environment approach (pass by reference)\ncreate_data_env &lt;- function() {\n    env &lt;- new.env()\n    env$data &lt;- data.frame(id = 1:5, value = rnorm(5))\n    return(env)\n}\n\nmodify_data &lt;- function(data_env, new_value) {\n    data_env$data$value &lt;- data_env$data$value + new_value\n}\n\n# Create data environment\nmy_data_env &lt;- create_data_env()\nprint(\"Original:\")\n\n[1] \"Original:\"\n\nprint(my_data_env$data)\n\n  id      value\n1  1  1.2339247\n2  2  0.3796644\n3  3  0.6839668\n4  4 -1.9422004\n5  5 -2.1878688\n\n# Modify (changes original!)\nmodify_data(my_data_env, 100)\nprint(\"After modification:\")\n\n[1] \"After modification:\"\n\nprint(my_data_env$data)  # Modified! \n\n  id     value\n1  1 101.23392\n2  2 100.37966\n3  3 100.68397\n4  4  98.05780\n5  5  97.81213\n\n# This is similar to how SAS datasets work",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#atomic-data-types",
    "href": "datatype_structure.html#atomic-data-types",
    "title": "1  R Fundamentals for SAS Users",
    "section": "5.1 Atomic Data Types",
    "text": "5.1 Atomic Data Types\nR has six atomic (basic) types. Understanding these is fundamental to data manipulation.\n\n5.1.1 Numeric Types\n\n# Double (default numeric type in R)\nnum_double &lt;- 42.5\nclass(num_double)\n\n[1] \"numeric\"\n\ntypeof(num_double)\n\n[1] \"double\"\n\n# Integer (requires L suffix)\nnum_integer &lt;- 42L\nclass(num_integer)\n\n[1] \"integer\"\n\ntypeof(num_integer)\n\n[1] \"integer\"\n\n# Automatic conversion\nx &lt;- 10      # Double\ny &lt;- 10L     # Integer\nz &lt;- x + y   # Result is double\ntypeof(z)\n\n[1] \"double\"\n\n# Checking numeric types\nis.numeric(num_double)   # TRUE\n\n[1] TRUE\n\nis.numeric(num_integer)  # TRUE\n\n[1] TRUE\n\nis.integer(num_integer)  # TRUE\n\n[1] TRUE\n\nis.integer(num_double)   # FALSE\n\n[1] FALSE\n\nis.double(num_double)    # TRUE\n\n[1] TRUE\n\n# Coercion\nas.integer(42.7)  # 42 (truncates)\n\n[1] 42\n\nas.numeric(\"123\")  # 123\n\n[1] 123\n\nas.numeric(\"abc\")  # NA with warning\n\n[1] NA\n\n\n\n\n5.1.2 Character (String) Types\n\n# Creating character variables\nchar1 &lt;- \"Hello\"\nchar2 &lt;- 'World'  # Single or double quotes work\nchar3 &lt;- \"Can include 'quotes' inside\"\n\n# Multi-line strings\nmulti_line &lt;- \"This is line 1\nThis is line 2\nThis is line 3\"\n\n# String operations\npaste(\"Hello\", \"World\")                    # \"Hello World\"\n\n[1] \"Hello World\"\n\npaste0(\"No\", \"Space\")                      # \"NoSpace\"\n\n[1] \"NoSpace\"\n\npaste(\"A\", \"B\", \"C\", sep = \"-\")           # \"A-B-C\"\n\n[1] \"A-B-C\"\n\nsprintf(\"Patient %d has BMI %.2f\", 101, 24.5)  # Formatted string\n\n[1] \"Patient 101 has BMI 24.50\"\n\n# String manipulation\ntoupper(\"hello\")                           # \"HELLO\"\n\n[1] \"HELLO\"\n\ntolower(\"HELLO\")                           # \"hello\"\n\n[1] \"hello\"\n\nnchar(\"Hello\")                             # 5 (length)\n\n[1] 5\n\nsubstr(\"Hello World\", 1, 5)                # \"Hello\"\n\n[1] \"Hello\"\n\ngsub(\"o\", \"0\", \"Hello World\")              # \"Hell0 W0rld\" (replace)\n\n[1] \"Hell0 W0rld\"\n\n# Check and convert\nis.character(char1)  # TRUE\n\n[1] TRUE\n\nas.character(123)    # \"123\"\n\n[1] \"123\"\n\n\n\n\n5.1.3 Logical (Boolean) Types\n\n# Creating logical values\nflag1 &lt;- TRUE\nflag2 &lt;- FALSE\nflag3 &lt;- T      # Shorthand (but TRUE preferred)\nflag4 &lt;- F      # Shorthand (but FALSE preferred)\n\n# Logical operations\nTRUE & FALSE   # AND:  FALSE\n\n[1] FALSE\n\nTRUE | FALSE   # OR:  TRUE\n\n[1] TRUE\n\n!TRUE          # NOT:  FALSE\n\n[1] FALSE\n\nTRUE && FALSE  # Short-circuit AND: FALSE (only evaluates what's needed)\n\n[1] FALSE\n\nTRUE || FALSE  # Short-circuit OR: TRUE\n\n[1] TRUE\n\n# Comparisons return logical\n5 &gt; 3          # TRUE\n\n[1] TRUE\n\n5 == 5         # TRUE\n\n[1] TRUE\n\n5 != 3         # TRUE\n\n[1] TRUE\n\n\"a\" %in% c(\"a\", \"b\", \"c\")  # TRUE\n\n[1] TRUE\n\n# Logical arithmetic (TRUE = 1, FALSE = 0)\nsum(c(TRUE, FALSE, TRUE, TRUE))     # 3\n\n[1] 3\n\nmean(c(TRUE, FALSE, TRUE, TRUE))    # 0.75\n\n[1] 0.75\n\n# Conversion\nas.logical(0)        # FALSE\n\n[1] FALSE\n\nas.logical(1)        # TRUE\n\n[1] TRUE\n\nas.logical(\"TRUE\")   # TRUE\n\n[1] TRUE\n\nas.logical(\"yes\")    # NA\n\n[1] NA\n\n\n\n\n5.1.4 Special Values\n\n# NA - Missing value (like .  in SAS)\nna_value &lt;- NA\nis.na(na_value)   # TRUE\n\n[1] TRUE\n\n# Different types of NA\nna_real &lt;- NA_real_        # Numeric NA\nna_int &lt;- NA_integer_      # Integer NA\nna_char &lt;- NA_character_   # Character NA\nna_logical &lt;- NA            # Logical NA\n\n# NULL - Absence of value (different from NA)\nnull_value &lt;- NULL\nis.null(null_value)  # TRUE\n\n[1] TRUE\n\nlength(NULL)         # 0\n\n[1] 0\n\nlength(NA)           # 1\n\n[1] 1\n\n# Inf - Infinity\ninf_value &lt;- Inf\n1 / 0                # Inf\n\n[1] Inf\n\n-1 / 0               # -Inf\n\n[1] -Inf\n\nis.infinite(Inf)     # TRUE\n\n[1] TRUE\n\nis.finite(Inf)       # FALSE\n\n[1] FALSE\n\n# NaN - Not a Number\nnan_value &lt;- NaN\n0 / 0                # NaN\n\n[1] NaN\n\nis.nan(nan_value)    # TRUE\n\n[1] TRUE\n\n# Testing for special values\ntest_values &lt;- c(1, NA, NaN, Inf, -Inf)\nis.na(test_values)       # TRUE for NA and NaN\n\n[1] FALSE  TRUE  TRUE FALSE FALSE\n\nis.nan(test_values)      # TRUE only for NaN\n\n[1] FALSE FALSE  TRUE FALSE FALSE\n\nis.infinite(test_values) # TRUE for Inf and -Inf\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\nis.finite(test_values)   # TRUE only for 1\n\n[1]  TRUE FALSE FALSE FALSE FALSE\n\n\n\n\n5.1.5 SAS to R Type Comparison\n\n# Create comparison table\ncomparison &lt;- data.frame(\n    SAS_Type = c(\"Numeric\", \"Character\", \"Logical (1/0)\", \".  (missing)\", \"Date (numeric)\"),\n    R_Type = c(\"numeric/integer\", \"character\", \"logical (TRUE/FALSE)\", \"NA\", \"Date class\"),\n    Example = c(\"42.5 or 42L\", '\"text\"', \"TRUE/FALSE\", \"NA\", 'as.Date(\"2025-12-18\")'),\n    stringsAsFactors = FALSE\n)\n\nprint(comparison)\n\n        SAS_Type               R_Type               Example\n1        Numeric      numeric/integer           42.5 or 42L\n2      Character            character                \"text\"\n3  Logical (1/0) logical (TRUE/FALSE)            TRUE/FALSE\n4   .  (missing)                   NA                    NA\n5 Date (numeric)           Date class as.Date(\"2025-12-18\")\n\n# Date example\nsas_date &lt;- 19709  # SAS date value for 2025-12-18\nr_date &lt;- as.Date(\"2025-12-18\")\nprint(r_date)\n\n[1] \"2025-12-18\"\n\nprint(class(r_date))\n\n[1] \"Date\"\n\n# Convert between systems\nr_date_from_sas &lt;- as.Date(sas_date, origin = \"1960-01-01\")\nprint(r_date_from_sas)\n\n[1] \"2013-12-17\"",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#vector-data-structures",
    "href": "datatype_structure.html#vector-data-structures",
    "title": "1  R Fundamentals for SAS Users",
    "section": "5.2 Vector Data Structures",
    "text": "5.2 Vector Data Structures\nVectors are the fundamental data structure in R - even single values are vectors of length 1.\n\n5.2.1 Creating Vectors\n\n# Combine function c()\nnumeric_vec &lt;- c(1, 2, 3, 4, 5)\nchar_vec &lt;- c(\"apple\", \"banana\", \"cherry\", \"date\")\nlogical_vec &lt;- c(TRUE, FALSE, TRUE, TRUE, FALSE)\n\n# Sequences\nseq1 &lt;- 1:10                        # Simple sequence\nseq2 &lt;- 10:1                        # Descending\nseq3 &lt;- seq(0, 100, by = 10)        # With step\nseq4 &lt;- seq(0, 1, length.out = 11)  # Specific length\nseq5 &lt;- rep(5, times = 3)           # Repeat value\nseq6 &lt;- rep(c(1, 2), times = 3)     # Repeat vector\nseq7 &lt;- rep(c(1, 2), each = 3)      # Repeat each element\n\nprint(seq1)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nprint(seq3)\n\n [1]   0  10  20  30  40  50  60  70  80  90 100\n\nprint(seq6)  # 1 2 1 2 1 2\n\n[1] 1 2 1 2 1 2\n\nprint(seq7)  # 1 1 1 2 2 2\n\n[1] 1 1 1 2 2 2\n\n\n\n\n5.2.2 Vector Properties and Operations\n\n# Vector properties\nvec &lt;- c(10, 20, 30, 40, 50)\n\nlength(vec)          # 5\n\n[1] 5\n\nclass(vec)           # \"numeric\"\n\n[1] \"numeric\"\n\ntypeof(vec)          # \"double\"\n\n[1] \"double\"\n\nstr(vec)             # Structure\n\n num [1:5] 10 20 30 40 50\n\n# Vectorized operations (applied element-wise)\nvec + 10             # 20 30 40 50 60\n\n[1] 20 30 40 50 60\n\nvec * 2              # 20 40 60 80 100\n\n[1]  20  40  60  80 100\n\nvec^2                # 100 400 900 1600 2500\n\n[1]  100  400  900 1600 2500\n\nsqrt(vec)            # Square root of each element\n\n[1] 3.162278 4.472136 5.477226 6.324555 7.071068\n\nlog(vec)             # Natural log of each element\n\n[1] 2.302585 2.995732 3.401197 3.688879 3.912023\n\n# Operations between vectors (element-wise)\nvec1 &lt;- c(1, 2, 3, 4, 5)\nvec2 &lt;- c(10, 20, 30, 40, 50)\nvec1 + vec2          # 11 22 33 44 55\n\n[1] 11 22 33 44 55\n\nvec1 * vec2          # 10 40 90 160 250\n\n[1]  10  40  90 160 250\n\n\n\n\n5.2.3 Named Vectors\n\n# Create named vector\nscores &lt;- c(Math = 95, English = 88, Science = 92, History = 85)\nprint(scores)\n\n   Math English Science History \n     95      88      92      85 \n\n# Access by name\nscores[\"Math\"]\n\nMath \n  95 \n\nscores[c(\"Math\", \"Science\")]\n\n   Math Science \n     95      92 \n\n# Get names\nnames(scores)\n\n[1] \"Math\"    \"English\" \"Science\" \"History\"\n\n# Add/modify names\ngrades &lt;- c(95, 88, 92, 85)\nnames(grades) &lt;- c(\"Math\", \"English\", \"Science\", \"History\")\nprint(grades)\n\n   Math English Science History \n     95      88      92      85 \n\n# Named vectors are useful for lookup tables\nmonth_days &lt;- c(Jan = 31, Feb = 28, Mar = 31, Apr = 30, May = 31, Jun = 30,\n                Jul = 31, Aug = 31, Sep = 30, Oct = 31, Nov = 30, Dec = 31)\nmonth_days[\"Feb\"]\n\nFeb \n 28 \n\n\n\n\n5.2.4 Vector Indexing and Subsetting\nwhich function is very useful for logical indexing.\n\n# Create vector for examples\nvec &lt;- c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)\n\n# Positive indexing (1-based, not 0-based like Python!)\nvec[1]               # First element:  10\n\n[1] 10\n\nvec[5]               # Fifth element: 50\n\n[1] 50\n\nvec[c(1, 3, 5)]      # Multiple elements: 10 30 50\n\n[1] 10 30 50\n\nvec[1:5]             # Range: 10 20 30 40 50\n\n[1] 10 20 30 40 50\n\n# Negative indexing (exclusion)\nvec[-1]              # All except first\n\n[1]  20  30  40  50  60  70  80  90 100\n\nvec[-c(1, 2)]        # All except first two\n\n[1]  30  40  50  60  70  80  90 100\n\nvec[-(1:5)]          # All except first five\n\n[1]  60  70  80  90 100\n\n# Logical indexing (very powerful!)\nvec[vec &gt; 50]        # Elements greater than 50\n\n[1]  60  70  80  90 100\n\nvec[vec %% 2 == 0]   # Even elements\n\n [1]  10  20  30  40  50  60  70  80  90 100\n\nvec[vec &gt;= 30 & vec &lt;= 70]  # Between 30 and 70\n\n[1] 30 40 50 60 70\n\n# Which function (returns indices)\nwhich(vec &gt; 50)      # Indices where condition is TRUE\n\n[1]  6  7  8  9 10\n\nvec[which.max(vec)]  # Maximum value\n\n[1] 100\n\nvec[which.min(vec)]  # Minimum value\n\n[1] 10\n\n\n\n\n5.2.5 Vector Type Coercion\n\n# Vectors must be homogeneous (all same type)\n# R coerces to most flexible type:  logical &lt; integer &lt; double &lt; character\n\nmixed1 &lt;- c(1, 2, \"three\")     # All become character\nprint(mixed1)\n\n[1] \"1\"     \"2\"     \"three\"\n\nclass(mixed1)\n\n[1] \"character\"\n\nmixed2 &lt;- c(TRUE, FALSE, 1, 2)  # All become numeric\nprint(mixed2)\n\n[1] 1 0 1 2\n\nclass(mixed2)\n\n[1] \"numeric\"\n\nmixed3 &lt;- c(TRUE, FALSE, \"yes\")  # All become character\nprint(mixed3)\n\n[1] \"TRUE\"  \"FALSE\" \"yes\"  \n\nclass(mixed3)\n\n[1] \"character\"\n\n# Explicit coercion\nchar_nums &lt;- c(\"1\", \"2\", \"3\", \"4\")\nas.numeric(char_nums)            # Convert to numeric\n\n[1] 1 2 3 4\n\nlogical_vals &lt;- c(1, 0, 1, 1, 0)\nas.logical(logical_vals)         # Convert to logical\n\n[1]  TRUE FALSE  TRUE  TRUE FALSE",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#lists---flexible-containers",
    "href": "datatype_structure.html#lists---flexible-containers",
    "title": "1  R Fundamentals for SAS Users",
    "section": "5.3 Lists - Flexible Containers",
    "text": "5.3 Lists - Flexible Containers\nLists can contain elements of different types and structures, including other lists.\n\n5.3.1 Creating Lists\n\n# Basic list creation\nmy_list &lt;- list(\n    numbers = c(1, 2, 3, 4, 5),\n    text = \"Hello World\",\n    flag = TRUE,\n    matrix_data = matrix(1:6, nrow = 2),\n    nested_list = list(a = 10, b = 20)\n)\n\nprint(my_list)\n\n$numbers\n[1] 1 2 3 4 5\n\n$text\n[1] \"Hello World\"\n\n$flag\n[1] TRUE\n\n$matrix_data\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n$nested_list\n$nested_list$a\n[1] 10\n\n$nested_list$b\n[1] 20\n\nstr(my_list)  # Structure is very helpful for lists\n\nList of 5\n $ numbers    : num [1:5] 1 2 3 4 5\n $ text       : chr \"Hello World\"\n $ flag       : logi TRUE\n $ matrix_data: int [1:2, 1:3] 1 2 3 4 5 6\n $ nested_list:List of 2\n  ..$ a: num 10\n  ..$ b: num 20\n\n\n\n\n5.3.2 Accessing List Elements\n\n# Three ways to access list elements\n\n# 1. Using $ (by name)\nmy_list$numbers\n\n[1] 1 2 3 4 5\n\nmy_list$text\n\n[1] \"Hello World\"\n\n# 2. Using [[ ]] (by name or index) - extracts element\nmy_list[[\"numbers\"]]\n\n[1] 1 2 3 4 5\n\nmy_list[[1]]\n\n[1] 1 2 3 4 5\n\nmy_list[[\"nested_list\"]]$a\n\n[1] 10\n\n# 3. Using [ ] - returns a list\nmy_list[\"numbers\"]   # Returns list with one element\n\n$numbers\n[1] 1 2 3 4 5\n\nmy_list[1]           # Same\n\n$numbers\n[1] 1 2 3 4 5\n\nclass(my_list[[1]])  # \"numeric\"\n\n[1] \"numeric\"\n\nclass(my_list[1])    # \"list\"\n\n[1] \"list\"\n\n# Accessing nested elements\nmy_list$nested_list$a\n\n[1] 10\n\nmy_list[[\"nested_list\"]][[\"a\"]]\n\n[1] 10\n\nmy_list[[5]][[1]]\n\n[1] 10\n\n\n\n\n5.3.3 Modifying Lists\n\n# Add new elements\nmy_list$new_element &lt;- c(100, 200, 300)\nmy_list[[\"another_element\"]] &lt;- \"New value\"\n\n# Modify existing elements\nmy_list$text &lt;- \"Modified text\"\n\n# Remove elements\nmy_list$new_element &lt;- NULL\n\n# Append lists\nlist1 &lt;- list(a = 1, b = 2)\nlist2 &lt;- list(c = 3, d = 4)\ncombined &lt;- c(list1, list2)\nprint(combined)\n\n$a\n[1] 1\n\n$b\n[1] 2\n\n$c\n[1] 3\n\n$d\n[1] 4\n\n# Get list names\nnames(my_list)\n\n[1] \"numbers\"         \"text\"            \"flag\"            \"matrix_data\"    \n[5] \"nested_list\"     \"another_element\"\n\n# Unnamed lists\nunnamed_list &lt;- list(10, \"text\", TRUE)\nprint(unnamed_list)\n\n[[1]]\n[1] 10\n\n[[2]]\n[1] \"text\"\n\n[[3]]\n[1] TRUE\n\nunnamed_list[[2]]  # Access by index only\n\n[1] \"text\"\n\n\n\n\n5.3.4 Practical List Applications\n\n# Storing analysis results\nperform_analysis &lt;- function(data) {\n    results &lt;- list(\n        summary_stats = summary(data),\n        mean_value = mean(data, na.rm = TRUE),\n        sd_value = sd(data, na.rm = TRUE),\n        n_missing = sum(is.na(data)),\n        n_total = length(data)\n    )\n    return(results)\n}\n\nsample_data &lt;- c(12, 15, 18, NA, 22, 25, 28, 31)\nanalysis_results &lt;- perform_analysis(sample_data)\nprint(analysis_results)\n\n$summary_stats\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n  12.00   16.50   22.00   21.57   26.50   31.00       1 \n\n$mean_value\n[1] 21.57143\n\n$sd_value\n[1] 6.948792\n\n$n_missing\n[1] 1\n\n$n_total\n[1] 8\n\n# Accessing results\nprint(paste(\"Mean:\", analysis_results$mean_value))\n\n[1] \"Mean: 21.5714285714286\"\n\nprint(paste(\"Missing values:\", analysis_results$n_missing))\n\n[1] \"Missing values: 1\"",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#data-frames---rs-version-of-sas-datasets",
    "href": "datatype_structure.html#data-frames---rs-version-of-sas-datasets",
    "title": "1  R Fundamentals for SAS Users",
    "section": "5.4 Data Frames - R’s Version of SAS Datasets",
    "text": "5.4 Data Frames - R’s Version of SAS Datasets\nData frames are the primary structure for tabular data in R.\n\n5.4.1 Creating Data Frames\n\n# Method 1: From vectors\nemployees_df &lt;- data.frame(\n    employee_id = 1:6,\n    name = c(\"John\", \"Jane\", \"Bob\", \"Alice\", \"Charlie\", \"Diana\"),\n    department = c(\"Sales\", \"IT\", \"IT\", \"Sales\", \"HR\", \"Sales\"),\n    salary = c(50000, 75000, 68000, 52000, 48000, 55000),\n    years_employed = c(2, 5, 3, 1, 4, 3),\n    full_time = c(TRUE, TRUE, FALSE, TRUE, TRUE, FALSE),\n    stringsAsFactors = FALSE  # Keep strings as character (important!)\n)\n\nprint(employees_df)\n\n  employee_id    name department salary years_employed full_time\n1           1    John      Sales  50000              2      TRUE\n2           2    Jane         IT  75000              5      TRUE\n3           3     Bob         IT  68000              3     FALSE\n4           4   Alice      Sales  52000              1      TRUE\n5           5 Charlie         HR  48000              4      TRUE\n6           6   Diana      Sales  55000              3     FALSE\n\n# Method 2: From lists\nemp_list &lt;- list(\n    employee_id = 1:3,\n    name = c(\"John\", \"Jane\", \"Bob\"),\n    salary = c(50000, 75000, 68000)\n)\ndf_from_list &lt;- as.data.frame(emp_list)\nprint(df_from_list)\n\n  employee_id name salary\n1           1 John  50000\n2           2 Jane  75000\n3           3  Bob  68000\n\n# Method 3: Read from file (most common)\n# employees_df &lt;- read.csv(\"employees. csv\")\n# employees_df &lt;- read.table(\"employees.txt\", header = TRUE)\n\n\n\n5.4.2 Data Frame Properties\n\n# Dimensions\nnrow(employees_df)      # Number of rows\n\n[1] 6\n\nncol(employees_df)      # Number of columns\n\n[1] 6\n\ndim(employees_df)       # Both:  rows, columns\n\n[1] 6 6\n\n# Names\nnames(employees_df)     # Column names\n\n[1] \"employee_id\"    \"name\"           \"department\"     \"salary\"        \n[5] \"years_employed\" \"full_time\"     \n\ncolnames(employees_df)  # Same\n\n[1] \"employee_id\"    \"name\"           \"department\"     \"salary\"        \n[5] \"years_employed\" \"full_time\"     \n\nrownames(employees_df)  # Row names (usually just numbers)\n\n[1] \"1\" \"2\" \"3\" \"4\" \"5\" \"6\"\n\n# Structure and summary\nstr(employees_df)       # Structure (like PROC CONTENTS)\n\n'data.frame':   6 obs. of  6 variables:\n $ employee_id   : int  1 2 3 4 5 6\n $ name          : chr  \"John\" \"Jane\" \"Bob\" \"Alice\" ...\n $ department    : chr  \"Sales\" \"IT\" \"IT\" \"Sales\" ...\n $ salary        : num  50000 75000 68000 52000 48000 55000\n $ years_employed: num  2 5 3 1 4 3\n $ full_time     : logi  TRUE TRUE FALSE TRUE TRUE FALSE\n\nsummary(employees_df)   # Summary statistics\n\n  employee_id       name            department            salary     \n Min.   :1.00   Length:6           Length:6           Min.   :48000  \n 1st Qu.:2.25   Class :character   Class :character   1st Qu.:50500  \n Median :3.50   Mode  :character   Mode  :character   Median :53500  \n Mean   :3.50                                         Mean   :58000  \n 3rd Qu.:4.75                                         3rd Qu.:64750  \n Max.   :6.00                                         Max.   :75000  \n years_employed full_time      \n Min.   :1.00   Mode :logical  \n 1st Qu.:2.25   FALSE:2        \n Median :3.00   TRUE :4        \n Mean   :3.00                  \n 3rd Qu.:3.75                  \n Max.   :5.00                  \n\nhead(employees_df, 3)   # First 3 rows\n\n  employee_id name department salary years_employed full_time\n1           1 John      Sales  50000              2      TRUE\n2           2 Jane         IT  75000              5      TRUE\n3           3  Bob         IT  68000              3     FALSE\n\ntail(employees_df, 2)   # Last 2 rows\n\n  employee_id    name department salary years_employed full_time\n5           5 Charlie         HR  48000              4      TRUE\n6           6   Diana      Sales  55000              3     FALSE\n\nglimpse(employees_df)   # tidyverse version (if loaded)\n\nRows: 6\nColumns: 6\n$ employee_id    &lt;int&gt; 1, 2, 3, 4, 5, 6\n$ name           &lt;chr&gt; \"John\", \"Jane\", \"Bob\", \"Alice\", \"Charlie\", \"Diana\"\n$ department     &lt;chr&gt; \"Sales\", \"IT\", \"IT\", \"Sales\", \"HR\", \"Sales\"\n$ salary         &lt;dbl&gt; 50000, 75000, 68000, 52000, 48000, 55000\n$ years_employed &lt;dbl&gt; 2, 5, 3, 1, 4, 3\n$ full_time      &lt;lgl&gt; TRUE, TRUE, FALSE, TRUE, TRUE, FALSE\n\n\n\n\n5.4.3 Accessing Data Frame Elements\n\n# Access columns\nemployees_df$name                    # By name with $\n\n[1] \"John\"    \"Jane\"    \"Bob\"     \"Alice\"   \"Charlie\" \"Diana\"  \n\nemployees_df[[\"name\"]]               # By name with [[]]\n\n[1] \"John\"    \"Jane\"    \"Bob\"     \"Alice\"   \"Charlie\" \"Diana\"  \n\nemployees_df[, \"name\"]               # By name with [,]\n\n[1] \"John\"    \"Jane\"    \"Bob\"     \"Alice\"   \"Charlie\" \"Diana\"  \n\nemployees_df[, 2]                    # By position\n\n[1] \"John\"    \"Jane\"    \"Bob\"     \"Alice\"   \"Charlie\" \"Diana\"  \n\n# Access rows\nemployees_df[1, ]                    # First row\n\n  employee_id name department salary years_employed full_time\n1           1 John      Sales  50000              2      TRUE\n\nemployees_df[1:3, ]                  # First three rows\n\n  employee_id name department salary years_employed full_time\n1           1 John      Sales  50000              2      TRUE\n2           2 Jane         IT  75000              5      TRUE\n3           3  Bob         IT  68000              3     FALSE\n\n# Access specific elements\nemployees_df[1, 2]                   # Row 1, column 2\n\n[1] \"John\"\n\nemployees_df[1, \"name\"]              # Row 1, column \"name\"\n\n[1] \"John\"\n\nemployees_df$name[1]                 # Element 1 of column \"name\"\n\n[1] \"John\"\n\n# Multiple columns\nemployees_df[, c(\"name\", \"salary\")]\n\n     name salary\n1    John  50000\n2    Jane  75000\n3     Bob  68000\n4   Alice  52000\n5 Charlie  48000\n6   Diana  55000\n\nemployees_df[, c(2, 4)]\n\n     name salary\n1    John  50000\n2    Jane  75000\n3     Bob  68000\n4   Alice  52000\n5 Charlie  48000\n6   Diana  55000\n\n# Subset with conditions\nemployees_df[employees_df$salary &gt; 50000, ]\n\n  employee_id  name department salary years_employed full_time\n2           2  Jane         IT  75000              5      TRUE\n3           3   Bob         IT  68000              3     FALSE\n4           4 Alice      Sales  52000              1      TRUE\n6           6 Diana      Sales  55000              3     FALSE\n\nemployees_df[employees_df$department == \"Sales\", ]\n\n  employee_id  name department salary years_employed full_time\n1           1  John      Sales  50000              2      TRUE\n4           4 Alice      Sales  52000              1      TRUE\n6           6 Diana      Sales  55000              3     FALSE\n\nemployees_df[employees_df$salary &gt; 50000 & employees_df$full_time, ]\n\n  employee_id  name department salary years_employed full_time\n2           2  Jane         IT  75000              5      TRUE\n4           4 Alice      Sales  52000              1      TRUE\n\n\n\n\n5.4.4 Modifying Data Frames\n\n# Add new column\nemployees_df$bonus &lt;- employees_df$salary * 0.10\n\n# Modify existing column\nemployees_df$salary &lt;- employees_df$salary * 1.05  # 5% raise\n\n# Add calculated column\nemployees_df$total_comp &lt;- employees_df$salary + employees_df$bonus\n\n# Delete column\nemployees_df$bonus &lt;- NULL\n\n# Rename columns\nnames(employees_df)[names(employees_df) == \"name\"] &lt;- \"employee_name\"\n\n# Add rows\nnew_employee &lt;- data.frame(\n    employee_id = 7,\n    employee_name = \"Eve\",\n    department = \"IT\",\n    salary = 70000,\n    years_employed = 2,\n    full_time = TRUE,\n    total_comp = 77000\n)\nemployees_df &lt;- rbind(employees_df, new_employee)\n\n# Reset column name back\nnames(employees_df)[names(employees_df) == \"employee_name\"] &lt;- \"name\"\n\n\n\n5.4.5 SAS DATA Step vs R Data Frame Operations\n: :: {.panel-tabset}",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#sas-1",
    "href": "datatype_structure.html#sas-1",
    "title": "1  R Fundamentals for SAS Users",
    "section": "5.5 SAS",
    "text": "5.5 SAS\n/* SAS DATA step */\nDATA analysis;\n    SET employees;\n    WHERE salary &gt; 50000;\n    \n    /* Create variables */\n    bonus = salary * 0.10;\n    total_comp = salary + bonus;\n    \n    /* Conditional logic */\n    IF department = 'Sales' THEN sales_flag = 1;\n    ELSE sales_flag = 0;\n    \n    /* Keep specific variables */\n    KEEP employee_id name salary bonus total_comp;\nRUN;",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#r-base",
    "href": "datatype_structure.html#r-base",
    "title": "1  R Fundamentals for SAS Users",
    "section": "5.6 R (Base)",
    "text": "5.6 R (Base)\n\n# Base R approach\nanalysis &lt;- employees[employees$salary &gt; 50000, ]\nanalysis$bonus &lt;- analysis$salary * 0.10\nanalysis$total_comp &lt;- analysis$salary + analysis$bonus\nanalysis$sales_flag &lt;- ifelse(analysis$department == \"Sales\", 1, 0)\nanalysis &lt;- analysis[, c(\"employee_id\", \"name\", \"salary\", \"bonus\", \"total_comp\")]",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#r-tidyverse",
    "href": "datatype_structure.html#r-tidyverse",
    "title": "1  R Fundamentals for SAS Users",
    "section": "5.7 R (tidyverse)",
    "text": "5.7 R (tidyverse)\n\n# tidyverse approach (more readable)\nanalysis &lt;- employees_df %&gt;%\n    filter(salary &gt; 50000) %&gt;%\n    mutate(\n        bonus = salary * 0.10,\n        total_comp = salary + bonus,\n        sales_flag = if_else(department == \"Sales\", 1, 0)\n    ) %&gt;%\n    select(employee_id, name, salary, bonus, total_comp)\n\nprint(analysis)\n\n:::",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#matrices-and-arrays",
    "href": "datatype_structure.html#matrices-and-arrays",
    "title": "1  R Fundamentals for SAS Users",
    "section": "5.8 Matrices and Arrays",
    "text": "5.8 Matrices and Arrays\nMatrices (2D) and arrays (N-dimensional) are homogeneous data structures.\n\n5.8.1 Creating and Using Matrices\n\n# Create matrix\nmat &lt;- matrix(1:12, nrow = 3, ncol = 4)\nprint(mat)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n# Matrix with specific fill pattern\nmat_byrow &lt;- matrix(1:12, nrow = 3, ncol = 4, byrow = TRUE)\nprint(mat_byrow)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n\n# Named dimensions\nmat_named &lt;- matrix(1:12, nrow = 3, ncol = 4,\n                    dimnames = list(c(\"Row1\", \"Row2\", \"Row3\"),\n                                   c(\"Col1\", \"Col2\", \"Col3\", \"Col4\")))\nprint(mat_named)\n\n     Col1 Col2 Col3 Col4\nRow1    1    4    7   10\nRow2    2    5    8   11\nRow3    3    6    9   12\n\n# Matrix properties\ndim(mat)         # Dimensions\n\n[1] 3 4\n\nnrow(mat)        # Number of rows\n\n[1] 3\n\nncol(mat)        # Number of columns\n\n[1] 4\n\nlength(mat)      # Total elements\n\n[1] 12\n\n# Matrix indexing\nmat[1, 2]        # Element at row 1, column 2\n\n[1] 4\n\nmat[1, ]         # First row\n\n[1]  1  4  7 10\n\nmat[, 2]         # Second column\n\n[1] 4 5 6\n\nmat[1: 2, 2: 3]    # Submatrix\n\n     [,1] [,2]\n[1,]    4    7\n[2,]    5    8\n\n\n\n\n5.8.2 Matrix Operations\n\n# Create matrices for operations\nA &lt;- matrix(c(1, 2, 3, 4), nrow = 2)\nB &lt;- matrix(c(5, 6, 7, 8), nrow = 2)\n\n# Element-wise operations\nA + B            # Element-wise addition\n\n     [,1] [,2]\n[1,]    6   10\n[2,]    8   12\n\nA * B            # Element-wise multiplication\n\n     [,1] [,2]\n[1,]    5   21\n[2,]   12   32\n\nA / B            # Element-wise division\n\n          [,1]      [,2]\n[1,] 0.2000000 0.4285714\n[2,] 0.3333333 0.5000000\n\n# Matrix multiplication\nA %*% B          # Matrix product\n\n     [,1] [,2]\n[1,]   23   31\n[2,]   34   46\n\n# Transpose\nt(A)\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n\n# Inverse (if square and invertible)\nsolve(A)\n\n     [,1] [,2]\n[1,]   -2  1.5\n[2,]    1 -0.5\n\n# Determinant\ndet(A)\n\n[1] -2\n\n# Eigenvalues and eigenvectors\neigen(A)\n\neigen() decomposition\n$values\n[1]  5.3722813 -0.3722813\n\n$vectors\n           [,1]       [,2]\n[1,] -0.5657675 -0.9093767\n[2,] -0.8245648  0.4159736\n\n\n\n\n5.8.3 Arrays (Multi-dimensional)\n\n# Create 3D array\narr &lt;- array(1:24, dim = c(3, 4, 2))\nprint(arr)\n\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]   13   16   19   22\n[2,]   14   17   20   23\n[3,]   15   18   21   24\n\n# Access elements\narr[1, 2, 1]     # Single element\n\n[1] 4\n\narr[, , 1]       # First \"slice\"\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\narr[1, , ]       # First row across all slices\n\n     [,1] [,2]\n[1,]    1   13\n[2,]    4   16\n[3,]    7   19\n[4,]   10   22\n\n# Array properties\ndim(arr)\n\n[1] 3 4 2\n\nlength(arr)\n\n[1] 24",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#tibbles---modern-data-frames",
    "href": "datatype_structure.html#tibbles---modern-data-frames",
    "title": "1  R Fundamentals for SAS Users",
    "section": "5.9 Tibbles - Modern Data Frames",
    "text": "5.9 Tibbles - Modern Data Frames\nTibbles are enhanced data frames from the tidyverse with better printing and behavior.\n\n5.9.1 Creating Tibbles\n\nlibrary(tibble)\n\n# Create tibble\nemployees_tbl &lt;- tibble(\n    employee_id = 1:6,\n    name = c(\"John\", \"Jane\", \"Bob\", \"Alice\", \"Charlie\", \"Diana\"),\n    department = c(\"Sales\", \"IT\", \"IT\", \"Sales\", \"HR\", \"Sales\"),\n    salary = c(50000, 75000, 68000, 52000, 48000, 55000),\n    start_date = as.Date(c(\"2023-01-15\", \"2020-06-01\", \"2022-03-10\",\n                           \"2024-02-20\", \"2021-09-05\", \"2022-11-12\"))\n)\n\nprint(employees_tbl)  # Better printing than data.frame\n\n# A tibble: 6 × 5\n  employee_id name    department salary start_date\n        &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;date&gt;    \n1           1 John    Sales       50000 2023-01-15\n2           2 Jane    IT          75000 2020-06-01\n3           3 Bob     IT          68000 2022-03-10\n4           4 Alice   Sales       52000 2024-02-20\n5           5 Charlie HR          48000 2021-09-05\n6           6 Diana   Sales       55000 2022-11-12\n\n# Tribble:  row-wise tibble creation\nemployees_tribble &lt;- tribble(\n    ~employee_id, ~name,      ~department, ~salary,\n    1,            \"John\",     \"Sales\",     50000,\n    2,            \"Jane\",     \"IT\",        75000,\n    3,            \"Bob\",      \"IT\",        68000\n)\nprint(employees_tribble)\n\n# A tibble: 3 × 4\n  employee_id name  department salary\n        &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;       &lt;dbl&gt;\n1           1 John  Sales       50000\n2           2 Jane  IT          75000\n3           3 Bob   IT          68000\n\n\n\n\n5.9.2 Tibble vs Data Frame Differences\n\n# Difference 1: Printing\n# Data frames print everything, tibbles show first 10 rows\ndf_large &lt;- data.frame(x = 1:100, y = 101:200)\ntbl_large &lt;- tibble(x = 1:100, y = 101:200)\n# print(df_large)   # Would print all 100 rows\nprint(tbl_large)    # Prints first 10 rows nicely\n\n# A tibble: 100 × 2\n       x     y\n   &lt;int&gt; &lt;int&gt;\n 1     1   101\n 2     2   102\n 3     3   103\n 4     4   104\n 5     5   105\n 6     6   106\n 7     7   107\n 8     8   108\n 9     9   109\n10    10   110\n# ℹ 90 more rows\n\n# Difference 2: Subsetting\ndf &lt;- data.frame(x = 1:3, y = 4:6)\ntbl &lt;- tibble(x = 1:3, y = 4:6)\n\ndf[, \"x\"]           # Returns vector\n\n[1] 1 2 3\n\ntbl[, \"x\"]          # Returns tibble\n\n# A tibble: 3 × 1\n      x\n  &lt;int&gt;\n1     1\n2     2\n3     3\n\n# Difference 3: Character vectors\ndf_char &lt;- data.frame(name = c(\"John\", \"Jane\"))\ntbl_char &lt;- tibble(name = c(\"John\", \"Jane\"))\n\nstr(df_char)        # Might convert to factor (depends on R version)\n\n'data.frame':   2 obs. of  1 variable:\n $ name: chr  \"John\" \"Jane\"\n\nstr(tbl_char)       # Always character\n\ntibble [2 × 1] (S3: tbl_df/tbl/data.frame)\n $ name: chr [1:2] \"John\" \"Jane\"\n\n# Difference 4: Column names\n# Tibbles allow non-syntactic names\ntbl_special &lt;- tibble(\n    `Column with spaces` = 1:3,\n    `2024` = 4:6\n)\nprint(tbl_special)\n\n# A tibble: 3 × 2\n  `Column with spaces` `2024`\n                 &lt;int&gt;  &lt;int&gt;\n1                    1      4\n2                    2      5\n3                    3      6\n\n\n\n\n5.9.3 Converting Between Data Frames and Tibbles\n\n# Convert data frame to tibble\ndf &lt;- data.frame(x = 1:3, y = 4:6)\ntbl &lt;- as_tibble(df)\n\n# Convert tibble to data frame\ntbl &lt;- tibble(x = 1:3, y = 4:6)\ndf &lt;- as.data.frame(tbl)\n\n# Check type\nis.data.frame(tbl)   # TRUE (tibbles are also data frames)\n\n[1] TRUE\n\nis_tibble(df)        # FALSE\n\n[1] FALSE\n\nis_tibble(tbl)       # TRUE\n\n[1] TRUE",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#data.-table---high-performance-option",
    "href": "datatype_structure.html#data.-table---high-performance-option",
    "title": "1  R Fundamentals for SAS Users",
    "section": "5.10 Data. table - High Performance Option",
    "text": "5.10 Data. table - High Performance Option\nData.table is optimized for speed and memory efficiency with large datasets.\n\n5.10.1 Creating Data.tables\n\nlibrary(data.table)\n\n# Create data. table\nemployees_dt &lt;- data.table(\n    employee_id = 1:1000,\n    department = sample(c(\"Sales\", \"IT\", \"HR\", \"Finance\"), 1000, replace = TRUE),\n    salary = round(rnorm(1000, mean = 60000, sd = 15000), 0),\n    years = sample(1:20, 1000, replace = TRUE)\n)\n\nprint(head(employees_dt))\n\n   employee_id department salary years\n         &lt;int&gt;     &lt;char&gt;  &lt;num&gt; &lt;int&gt;\n1:           1         HR  83890     8\n2:           2         HR  68834    18\n3:           3         IT  34684    13\n4:           4         IT  57250     4\n5:           5         IT  69354     3\n6:           6         IT  55388     9\n\n# Convert from data frame\ndf &lt;- data.frame(x = 1:3, y = 4:6)\ndt &lt;- as.data.table(df)\n\n\n\n5.10.2 Data.table Syntax: DT[i, j, by]\nThe data.table syntax follows the pattern: DT[where, select, group by]\n\n# i: Filter rows (WHERE clause)\nemployees_dt[salary &gt; 70000]\n\n     employee_id department salary years\n           &lt;int&gt;     &lt;char&gt;  &lt;num&gt; &lt;int&gt;\n  1:           1         HR  83890     8\n  2:          12      Sales  89475    16\n  3:          13         HR  73650    15\n  4:          16      Sales  80623     9\n  5:          19         HR  76702    16\n ---                                    \n258:         979    Finance  87215    17\n259:         986      Sales  72406    10\n260:         988         IT  91063    13\n261:         991      Sales  82844    20\n262:         996         HR  71935     9\n\nemployees_dt[department == \"IT\"]\n\n     employee_id department salary years\n           &lt;int&gt;     &lt;char&gt;  &lt;num&gt; &lt;int&gt;\n  1:           3         IT  34684    13\n  2:           4         IT  57250     4\n  3:           5         IT  69354     3\n  4:           6         IT  55388     9\n  5:          11         IT  62706     5\n ---                                    \n258:         988         IT  91063    13\n259:         989         IT  65752    16\n260:         994         IT  65873    12\n261:         998         IT  55284     3\n262:         999         IT  47145     4\n\n# j: Select/compute columns (SELECT clause)\nemployees_dt[, .(employee_id, salary)]\n\n      employee_id salary\n            &lt;int&gt;  &lt;num&gt;\n   1:           1  83890\n   2:           2  68834\n   3:           3  34684\n   4:           4  57250\n   5:           5  69354\n  ---                   \n 996:         996  71935\n 997:         997  56779\n 998:         998  55284\n 999:         999  47145\n1000:        1000  62882\n\nemployees_dt[, mean_salary := mean(salary)]\n\n# by: Group by (GROUP BY clause)\nemployees_dt[, .(avg_salary = mean(salary)), by = department]\n\n   department avg_salary\n       &lt;char&gt;      &lt;num&gt;\n1:         HR   59341.27\n2:         IT   60925.55\n3:    Finance   58277.72\n4:      Sales   61343.57\n\nemployees_dt[, .(count = .N), by = department]  # . N is row count\n\n   department count\n       &lt;char&gt; &lt;int&gt;\n1:         HR   243\n2:         IT   262\n3:    Finance   239\n4:      Sales   256\n\n# Combining i, j, by\nemployees_dt[salary &gt; 50000, \n             .(avg_salary = mean(salary), count = .N), \n             by = department]\n\n   department avg_salary count\n       &lt;char&gt;      &lt;num&gt; &lt;int&gt;\n1:         HR   66173.30   179\n2:         IT   67569.79   192\n3:    Finance   64990.17   173\n4:      Sales   67113.16   197\n\n# Multiple group by\nemployees_dt[, .(avg_salary = mean(salary)), \n             by = .(department, years_bucket = cut(years, breaks = c(0, 5, 10, 20)))]\n\n    department years_bucket avg_salary\n        &lt;char&gt;       &lt;fctr&gt;      &lt;num&gt;\n 1:         HR       (5,10]   59110.69\n 2:         HR      (10,20]   60008.93\n 3:         IT      (10,20]   61505.98\n 4:         IT        (0,5]   61337.91\n 5:         IT       (5,10]   59300.22\n 6:    Finance      (10,20]   58097.98\n 7:      Sales      (10,20]   60699.58\n 8:      Sales       (5,10]   60804.81\n 9:      Sales        (0,5]   63464.51\n10:    Finance        (0,5]   60479.92\n11:    Finance       (5,10]   56175.71\n12:         HR        (0,5]   58272.95\n\n\n\n\n5.10.3 Data.table Performance Advantages\n\n# Create large datasets for comparison\nn &lt;- 1000000\n\n# Data frame approach\ndf_large &lt;- data.frame(\n    id = 1:n,\n    group = sample(letters[1:100], n, replace = TRUE),\n    value = rnorm(n)\n)\n\n# Data.table approach\ndt_large &lt;- data.table(\n    id = 1:n,\n    group = sample(letters[1:100], n, replace = TRUE),\n    value = rnorm(n)\n)\n\n# Speed comparison:  group aggregation\nsystem.time({\n    result_df &lt;- aggregate(value ~ group, data = df_large, FUN = mean)\n})\n\n   user  system elapsed \n  0.096   0.012   0.108 \n\nsystem.time({\n    result_dt &lt;- dt_large[, .(mean_value = mean(value)), by = group]\n})\n\n   user  system elapsed \n  0.101   0.003   0.053 \n\n# data.table is typically much faster for large data operations",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#factors---categorical-variables",
    "href": "datatype_structure.html#factors---categorical-variables",
    "title": "1  R Fundamentals for SAS Users",
    "section": "5.11 Factors - Categorical Variables",
    "text": "5.11 Factors - Categorical Variables\nFactors represent categorical data, similar to SAS formats/value labels.\n\n5.11.1 Creating Factors\n\n# Create factor from character vector\ngender_char &lt;- c(\"M\", \"F\", \"F\", \"M\", \"M\", \"F\")\ngender_factor &lt;- factor(gender_char)\nprint(gender_factor)\n\n[1] M F F M M F\nLevels: F M\n\n# Levels are shown\nlevels(gender_factor)\n\n[1] \"F\" \"M\"\n\n# With explicit levels and labels\ngender_factor2 &lt;- factor(\n    c(\"M\", \"F\", \"F\", \"M\", \"M\", \"F\"),\n    levels = c(\"M\", \"F\"),\n    labels = c(\"Male\", \"Female\")\n)\nprint(gender_factor2)\n\n[1] Male   Female Female Male   Male   Female\nLevels: Male Female\n\n# Ordered factors\neducation &lt;- factor(\n    c(\"HS\", \"BS\", \"MS\", \"PhD\", \"BS\", \"HS\"),\n    levels = c(\"HS\", \"BS\", \"MS\", \"PhD\"),\n    ordered = TRUE\n)\nprint(education)\n\n[1] HS  BS  MS  PhD BS  HS \nLevels: HS &lt; BS &lt; MS &lt; PhD\n\nprint(education[2] &lt; education[3])  # TRUE:  BS &lt; MS\n\n[1] TRUE\n\n\n\n\n5.11.2 Working with Factors\n\n# Factor properties\nlevels(gender_factor)\n\n[1] \"F\" \"M\"\n\nnlevels(gender_factor)\n\n[1] 2\n\nis.factor(gender_factor)\n\n[1] TRUE\n\nis.ordered(education)\n\n[1] TRUE\n\n# Convert factor to character/numeric\nas.character(gender_factor)\n\n[1] \"M\" \"F\" \"F\" \"M\" \"M\" \"F\"\n\nas.numeric(gender_factor)  # Returns level codes (1, 2, ...)\n\n[1] 2 1 1 2 2 1\n\n# Reorder levels\ngender_reordered &lt;- factor(gender_factor, levels = c(\"F\", \"M\"))\nlevels(gender_reordered)\n\n[1] \"F\" \"M\"\n\n# Add levels\ngender_expanded &lt;- factor(gender_factor, levels = c(\"M\", \"F\", \"O\"))\nlevels(gender_expanded)\n\n[1] \"M\" \"F\" \"O\"\n\n# Relabel levels\nlevels(gender_factor) &lt;- c(\"Male\", \"Female\")\nprint(gender_factor)\n\n[1] Female Male   Male   Female Female Male  \nLevels: Male Female\n\n\n\n\n5.11.3 Practical Uses for Factors\n\n# Create survey data\nsurvey &lt;- data.frame(\n    id = 1:10,\n    satisfaction = factor(\n        c(\"High\", \"Low\", \"Medium\", \"High\", \"Low\", \"High\", \"Medium\", \"High\", \"Low\", \"Medium\"),\n        levels = c(\"Low\", \"Medium\", \"High\"),\n        ordered = TRUE\n    ),\n    region = factor(c(\"North\", \"South\", \"North\", \"West\", \"East\", \n                     \"North\", \"South\", \"East\", \"West\", \"North\"))\n)\n\n# Frequency tables (like PROC FREQ)\ntable(survey$satisfaction)\n\n\n   Low Medium   High \n     3      3      4 \n\ntable(survey$region)\n\n\n East North South  West \n    2     4     2     2 \n\ntable(survey$satisfaction, survey$region)  # Cross-tabulation\n\n        \n         East North South West\n  Low       1     0     1    1\n  Medium    0     2     1    0\n  High      1     2     0    1\n\n# Proportions\nprop.table(table(survey$satisfaction))\n\n\n   Low Medium   High \n   0.3    0.3    0.4 \n\n# Factors preserve level order in plots and analyses\n# (Very useful for ordered categories like satisfaction, education, etc.)\n\n\n\n5.11.4 Factor Pitfalls and Solutions\n\n# Pitfall 1: Factors look like characters but aren't\nfactor_var &lt;- factor(c(\"10\", \"20\", \"30\"))\n# as.numeric(factor_var)  # Returns 1, 2, 3 (NOT 10, 20, 30!)\nas.numeric(as.character(factor_var))  # Returns 10, 20, 30 (correct)\n\n[1] 10 20 30\n\n# Pitfall 2: Can't add values not in levels\ncolors &lt;- factor(c(\"red\", \"blue\", \"green\"), levels = c(\"red\", \"blue\", \"green\"))\n# colors[4] &lt;- \"yellow\"  # Would produce NA (not an error!)\n\n# Solution: Add level first\nlevels(colors) &lt;- c(levels(colors), \"yellow\")\ncolors[4] &lt;- \"yellow\"\nprint(colors)\n\n[1] red    blue   green  yellow\nLevels: red blue green yellow\n\n# Pitfall 3: stringsAsFactors in data.frame (older R versions)\n# In R &lt; 4.0.0, characters were automatically converted to factors\n# Always use stringsAsFactors = FALSE or upgrade to R &gt;= 4.0.0\ndf_safe &lt;- data.frame(\n    name = c(\"John\", \"Jane\"),\n    stringsAsFactors = FALSE\n)\nstr(df_safe)  # character, not factor\n\n'data.frame':   2 obs. of  1 variable:\n $ name: chr  \"John\" \"Jane\"",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#using-built-in-functions",
    "href": "datatype_structure.html#using-built-in-functions",
    "title": "1  R Fundamentals for SAS Users",
    "section": "6.1 Using Built-in Functions",
    "text": "6.1 Using Built-in Functions\nR has thousands of built-in functions for data analysis.\n\n6.1.1 Statistical Functions\n\n# Create sample data\nnumbers &lt;- c(12, 18, 23, 28, 15, NA, 34, 29, 19, 25)\n\n# Measures of central tendency\nmean(numbers, na.rm = TRUE)        # Mean\n\n[1] 22.55556\n\nmedian(numbers, na.rm = TRUE)      # Median\n\n[1] 23\n\n# mode (no built-in mode function)\n\n# Measures of dispersion\nsd(numbers, na.rm = TRUE)          # Standard deviation\n\n[1] 7.16085\n\nvar(numbers, na.rm = TRUE)         # Variance\n\n[1] 51.27778\n\nIQR(numbers, na.rm = TRUE)         # Interquartile range\n\n[1] 10\n\nrange(numbers, na.rm = TRUE)       # Min and max\n\n[1] 12 34\n\nmad(numbers, na.rm = TRUE)         # Median absolute deviation\n\n[1] 7.413\n\n# Summary statistics\nmin(numbers, na.rm = TRUE)\n\n[1] 12\n\nmax(numbers, na.rm = TRUE)\n\n[1] 34\n\nsum(numbers, na.rm = TRUE)\n\n[1] 203\n\nprod(numbers, na.rm = TRUE)        # Product\n\n[1] 977240376000\n\nlength(numbers)                     # Count all\n\n[1] 10\n\nsum(! is.na(numbers))               # Count non-missing\n\n[1] 9\n\n# Quantiles\nquantile(numbers, na.rm = TRUE)    # Default:  0%, 25%, 50%, 75%, 100%\n\n  0%  25%  50%  75% 100% \n  12   18   23   28   34 \n\nquantile(numbers, probs = c(0.1, 0.9), na.rm = TRUE)  # 10th and 90th percentiles\n\n 10%  90% \n14.4 30.0 \n\n# Summary function (multiple stats at once)\nsummary(numbers)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n  12.00   18.00   23.00   22.56   28.00   34.00       1 \n\n\n\n\n6.1.2 Mathematical Functions\n\n# Arithmetic\nabs(-5)                    # Absolute value\n\n[1] 5\n\nsqrt(16)                   # Square root\n\n[1] 4\n\nexp(2)                     # Exponential\n\n[1] 7.389056\n\nlog(100)                   # Natural logarithm\n\n[1] 4.60517\n\nlog10(100)                 # Base-10 logarithm\n\n[1] 2\n\nlog(8, base = 2)           # Custom base logarithm\n\n[1] 3\n\n# Rounding\nround(3.14159, digits = 2) # 3.14\n\n[1] 3.14\n\nfloor(3.9)                 # 3 (round down)\n\n[1] 3\n\nceiling(3.1)               # 4 (round up)\n\n[1] 4\n\ntrunc(3.9)                 # 3 (truncate decimal)\n\n[1] 3\n\nsignif(123456, digits = 3) # 123000 (significant figures)\n\n[1] 123000\n\n# Trigonometry\nsin(pi/2)                  # 1\n\n[1] 1\n\ncos(0)                     # 1\n\n[1] 1\n\ntan(pi/4)                  # 1\n\n[1] 1\n\nasin(1)                    # pi/2 (arcsin)\n\n[1] 1.570796\n\n# Powers and roots\n2^10                       # 1024\n\n[1] 1024\n\n10^3                       # 1000\n\n[1] 1000\n\n27^(1/3)                   # 3 (cube root)\n\n[1] 3\n\n\n\n\n6.1.3 String Functions\n\n# Basic string operations\ntext &lt;- \"  Hello World  \"\n\nnchar(text)                          # Length (with spaces)\n\n[1] 15\n\ntoupper(text)                        # \"  HELLO WORLD  \"\n\n[1] \"  HELLO WORLD  \"\n\ntolower(text)                        # \"  hello world  \"\n\n[1] \"  hello world  \"\n\ntrimws(text)                         # Remove leading/trailing whitespace\n\n[1] \"Hello World\"\n\n# Substring operations\nsubstr(\"Hello World\", 1, 5)          # \"Hello\"\n\n[1] \"Hello\"\n\nsubstring(\"Hello World\", 7)          # \"World\"\n\n[1] \"World\"\n\n# Search and replace\ngrepl(\"World\", text)                 # TRUE (pattern found)\n\n[1] TRUE\n\ngrep(\"World\", c(\"Hello\", \"World\", \"Goodbye\"))  # 2 (position)\n\n[1] 2\n\nsub(\"World\", \"Universe\", text)       # Replace first occurrence\n\n[1] \"  Hello Universe  \"\n\ngsub(\"o\", \"0\", text)                 # Replace all occurrences\n\n[1] \"  Hell0 W0rld  \"\n\n# Split strings\nstrsplit(\"apple,banana,cherry\", \",\") # Split by delimiter\n\n[[1]]\n[1] \"apple\"  \"banana\" \"cherry\"\n\n# Paste strings\npaste(\"Hello\", \"World\")              # \"Hello World\" (with space)\n\n[1] \"Hello World\"\n\npaste0(\"Hello\", \"World\")             # \"HelloWorld\" (no space)\n\n[1] \"HelloWorld\"\n\npaste(c(\"A\", \"B\", \"C\"), collapse = \"-\")  # \"A-B-C\"\n\n[1] \"A-B-C\"\n\n# Formatted strings (like sprintf in C)\nsprintf(\"Patient %d:  BMI = %.2f\", 12345, 24.567)\n\n[1] \"Patient 12345:  BMI = 24.57\"\n\n\n\n\n6.1.4 Type Checking and Conversion Functions\n\n# Type checking (is.* functions)\nx &lt;- 42\nis.numeric(x)\n\n[1] TRUE\n\nis.integer(x)\n\n[1] FALSE\n\nis.character(x)\n\n[1] FALSE\n\nis.logical(x)\n\n[1] FALSE\n\nis.factor(x)\n\n[1] FALSE\n\nis.data.frame(x)\n\n[1] FALSE\n\nis.list(x)\n\n[1] FALSE\n\nis.matrix(x)\n\n[1] FALSE\n\nis.na(x)\n\n[1] FALSE\n\nis.null(x)\n\n[1] FALSE\n\n# Type conversion (as.* functions)\nas.character(42)              # \"42\"\n\n[1] \"42\"\n\nas.numeric(\"42\")              # 42\n\n[1] 42\n\nas.integer(42.7)              # 42 (truncates)\n\n[1] 42\n\nas.logical(1)                 # TRUE\n\n[1] TRUE\n\nas.factor(c(\"A\", \"B\", \"C\"))\n\n[1] A B C\nLevels: A B C\n\nas.data.frame(matrix(1:6, nrow = 2))\n\n  V1 V2 V3\n1  1  3  5\n2  2  4  6\n\nas.list(c(1, 2, 3))\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n\nas.matrix(data.frame(x = 1:3, y = 4:6))\n\n     x y\n[1,] 1 4\n[2,] 2 5\n[3,] 3 6",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#sas-proc-to-r-function-mapping",
    "href": "datatype_structure.html#sas-proc-to-r-function-mapping",
    "title": "1  R Fundamentals for SAS Users",
    "section": "6.2 SAS PROC to R Function Mapping",
    "text": "6.2 SAS PROC to R Function Mapping\nHere’s a comprehensive mapping of common SAS procedures to R equivalents:\n\n# Create mapping table\nsas_to_r &lt;- data.frame(\n    SAS_Proc = c(\n        \"PROC MEANS\",\n        \"PROC FREQ\",\n        \"PROC PRINT\",\n        \"PROC SORT\",\n        \"PROC CONTENTS\",\n        \"PROC SQL\",\n        \"PROC UNIVARIATE\",\n        \"PROC CORR\",\n        \"PROC REG\",\n        \"PROC LOGISTIC\",\n        \"PROC TABULATE\",\n        \"PROC TRANSPOSE\",\n        \"PROC IMPORT\",\n        \"PROC EXPORT\"\n    ),\n    R_Function = c(\n        \"summary(), mean(), sd()\",\n        \"table(), prop.table()\",\n        \"print(), head(), View()\",\n        \"sort(), order(), arrange()\",\n        \"str(), glimpse(), attributes()\",\n        \"sqldf(), dplyr verbs\",\n        \"summary(), psych::describe()\",\n        \"cor(), cor.test()\",\n        \"lm(), summary()\",\n        \"glm(family='binomial')\",\n        \"ftable(), aggregate()\",\n        \"t(), pivot_longer()/pivot_wider()\",\n        \"read.csv(), read_excel()\",\n        \"write.csv(), write_xlsx()\"\n    ),\n    Package = c(\n        \"base\",\n        \"base\",\n        \"base\",\n        \"base/dplyr\",\n        \"base/dplyr\",\n        \"sqldf/dplyr\",\n        \"base/psych\",\n        \"base\",\n        \"stats\",\n        \"stats\",\n        \"base/tidyr\",\n        \"base/tidyr\",\n        \"base/readxl\",\n        \"base/writexl\"\n    ),\n    stringsAsFactors = FALSE\n)\n\nprint(sas_to_r)\n\n          SAS_Proc                        R_Function      Package\n1       PROC MEANS           summary(), mean(), sd()         base\n2        PROC FREQ             table(), prop.table()         base\n3       PROC PRINT           print(), head(), View()         base\n4        PROC SORT        sort(), order(), arrange()   base/dplyr\n5    PROC CONTENTS    str(), glimpse(), attributes()   base/dplyr\n6         PROC SQL              sqldf(), dplyr verbs  sqldf/dplyr\n7  PROC UNIVARIATE      summary(), psych::describe()   base/psych\n8        PROC CORR                 cor(), cor.test()         base\n9         PROC REG                   lm(), summary()        stats\n10   PROC LOGISTIC            glm(family='binomial')        stats\n11   PROC TABULATE             ftable(), aggregate()   base/tidyr\n12  PROC TRANSPOSE t(), pivot_longer()/pivot_wider()   base/tidyr\n13     PROC IMPORT          read.csv(), read_excel()  base/readxl\n14     PROC EXPORT         write.csv(), write_xlsx() base/writexl\n\n\n\n6.2.1 Practical Examples: SAS to R\n: :: {.panel-tabset}",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#proc-means",
    "href": "datatype_structure.html#proc-means",
    "title": "1  R Fundamentals for SAS Users",
    "section": "6.3 PROC MEANS",
    "text": "6.3 PROC MEANS\n\n# Create data\ndata &lt;- data.frame(\n    group = rep(c(\"A\", \"B\", \"C\"), each = 10),\n    value = c(rnorm(10, 100, 15), rnorm(10, 110, 15), rnorm(10, 95, 15))\n)\n\n# SAS:  PROC MEANS DATA=data MEAN STD MIN MAX; VAR value; CLASS group; RUN;\n\n# R (base)\naggregate(value ~ group, data = data, \n          FUN = function(x) c(mean = mean(x), sd = sd(x), \n                             min = min(x), max = max(x)))\n\n  group value.mean   value.sd  value.min  value.max\n1     A  90.276117  20.203954  58.422536 121.959247\n2     B 110.232054  15.500029  92.842580 136.464625\n3     C  97.994446   8.416045  86.678557 114.796775\n\n# R (dplyr)\ndata %&gt;%\n    group_by(group) %&gt;%\n    summarise(\n        n = n(),\n        mean = mean(value),\n        sd = sd(value),\n        min = min(value),\n        max = max(value)\n    )\n\n# A tibble: 3 × 6\n  group     n  mean    sd   min   max\n  &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 A        10  90.3 20.2   58.4  122.\n2 B        10 110.  15.5   92.8  136.\n3 C        10  98.0  8.42  86.7  115.",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#proc-freq",
    "href": "datatype_structure.html#proc-freq",
    "title": "1  R Fundamentals for SAS Users",
    "section": "6.4 PROC FREQ",
    "text": "6.4 PROC FREQ\n\n# Create data\nsurvey_data &lt;- data.frame(\n    gender = sample(c(\"M\", \"F\"), 100, replace = TRUE),\n    satisfaction = sample(c(\"Low\", \"Medium\", \"High\"), 100, replace = TRUE)\n)\n\n# SAS: PROC FREQ DATA=survey_data; TABLES gender satisfaction gender*satisfaction; RUN;\n\n# R:  One-way frequency\ntable(survey_data$gender)\n\n\n F  M \n50 50 \n\nprop.table(table(survey_data$gender))\n\n\n  F   M \n0.5 0.5 \n\n# Two-way cross-tabulation\ntable(survey_data$gender, survey_data$satisfaction)\n\n   \n    High Low Medium\n  F   16  20     14\n  M   22  18     10\n\nprop.table(table(survey_data$gender, survey_data$satisfaction))\n\n   \n    High  Low Medium\n  F 0.16 0.20   0.14\n  M 0.22 0.18   0.10\n\n# With dplyr\nsurvey_data %&gt;%\n    count(gender, satisfaction) %&gt;%\n    mutate(proportion = n / sum(n))\n\n  gender satisfaction  n proportion\n1      F         High 16       0.16\n2      F          Low 20       0.20\n3      F       Medium 14       0.14\n4      M         High 22       0.22\n5      M          Low 18       0.18\n6      M       Medium 10       0.10",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#proc-sort",
    "href": "datatype_structure.html#proc-sort",
    "title": "1  R Fundamentals for SAS Users",
    "section": "6.5 PROC SORT",
    "text": "6.5 PROC SORT\n\n# Create data\nunsorted &lt;- data.frame(\n    id = c(3, 1, 4, 2, 5),\n    name = c(\"Charlie\", \"Alice\", \"David\", \"Bob\", \"Eve\"),\n    score = c(85, 92, 78, 88, 95)\n)\n\n# SAS: PROC SORT DATA=unsorted OUT=sorted; BY score; RUN;\n\n# R (base)\nsorted_base &lt;- unsorted[order(unsorted$score), ]\nsorted_desc &lt;- unsorted[order(-unsorted$score), ]  # Descending\n\n# R (dplyr)\nsorted_dplyr &lt;- unsorted %&gt;% arrange(score)\nsorted_desc_dplyr &lt;- unsorted %&gt;% arrange(desc(score))\n\nprint(sorted_dplyr)\n\n  id    name score\n1  4   David    78\n2  3 Charlie    85\n3  2     Bob    88\n4  1   Alice    92\n5  5     Eve    95\n\n\n:::",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#getting-help-in-r",
    "href": "datatype_structure.html#getting-help-in-r",
    "title": "1  R Fundamentals for SAS Users",
    "section": "6.6 Getting Help in R",
    "text": "6.6 Getting Help in R\nR has comprehensive built-in documentation and help systems.\n\n6.6.1 Basic Help Commands\n\n# Help on specific function\n? mean\nhelp(mean)\n\n# Search help for keyword\n?? regression\nhelp.search(\"regression\")\n\n# Find functions with pattern in name\napropos(\"mean\")\n\n# Examples from help page\nexample(mean)\nexample(plot)\n\n# See function arguments\nargs(mean)\nargs(lm)\n\n# See function source code\nmean.default\nlm  # For most functions, just type the name\n\n\n\n6.6.2 Exploring Packages and Functions\n\n# List all installed packages\ninstalled.packages()\n\n# List functions in a package\nls(\"package:dplyr\")\n\n# Help on a package\nhelp(package = \"dplyr\")\n\n# Vignettes (package tutorials)\nvignette()                    # List all vignettes\nvignette(\"dplyr\")             # Specific vignette\nbrowseVignettes(\"dplyr\")      # Browse all package vignettes\n\n\n\n6.6.3 Online Resources and Cheat Sheets\n\n# R documentation website\n# https://www.rdocumentation.org/\n\n# RStudio cheat sheets\n# https://posit.co/resources/cheatsheets/\n\n# Stack Overflow for R questions\n# https://stackoverflow.com/questions/tagged/r\n\n# R-bloggers for tutorials\n# https://www.r-bloggers.com/",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure.html#writing-custom-functions",
    "href": "datatype_structure.html#writing-custom-functions",
    "title": "1  R Fundamentals for SAS Users",
    "section": "6.7 Writing Custom Functions",
    "text": "6.7 Writing Custom Functions\nCreating reusable functions is essential for efficient R programming.\n\n6.7.1 Basic Function Definition\n\n# Simple function\ncalculate_bmi &lt;- function(weight_kg, height_m) {\n    bmi &lt;- weight_kg / (height_m^2)\n    return(bmi)\n}\n\n# Test function\nmy_bmi &lt;- calculate_bmi(70, 1.75)\nprint(paste(\"BMI:\", round(my_bmi, 2)))\n\n[1] \"BMI: 22.86\"\n\n# Calculate for multiple people\nweights &lt;- c(70, 85, 60)\nheights &lt;- c(1.75, 1.80, 1.65)\nbmis &lt;- mapply(calculate_bmi, weights, heights)\nprint(round(bmis, 2))\n\n[1] 22.86 26.23 22.04\n\n\n\n\n6.7.2 Function with Default Arguments\n\n# Function with default parameters\ngreet_user &lt;- function(name, greeting = \"Hello\") {\n    message &lt;- paste(greeting, name)\n    return(message)\n}\n# Test function\nprint(greet_user(\"Alice\"))               # Uses default greeting\n\n[1] \"Hello Alice\"\n\nprint(greet_user(\"Bob\", greeting = \"Hi\")) # Custom greeting\n\n[1] \"Hi Bob\"\n\n\n\n\n6.7.3 Function with Variable Number of Arguments\n\n# Function that accepts variable number of arguments\nsum_numbers &lt;- function(...) {\n    numbers &lt;- c(...)\n    total &lt;- sum(numbers, na.rm = TRUE)\n    return(total)\n}\n# Test function\nprint(sum_numbers(1, 2, 3, 4, 5))\n\n[1] 15\n\nprint(sum_numbers(10, 20, NA, 30))\n\n[1] 60",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals for SAS Users</span>"
    ]
  },
  {
    "objectID": "datatype_structure_exercise.html",
    "href": "datatype_structure_exercise.html",
    "title": "2  datatype and structure exercise",
    "section": "",
    "text": "3 Exercise 1\nInstall and load the following packages\n{tidyverse} {admiral} {dplyr} {tidyr} {admiral.test}\n\n\nShow solution\n#installing the packages\ninstall.packages(c(\"tidyverse\", \"admiral\", \"dplyr\", \"tidyr\"))\n\nlibrary(tidyverse)\nlibrary(admiral)\nlibrary(admiral.test)\nlibrary(dplyr)\nlibrary(tidyr)\n\n\n\n\n4 Exercise 2\nImport adsl.sas7bdat as adsl\n\n\nShow solution\nlibrary(haven)\nadsl &lt;-  read_sas(\"data/adsl.sas7bdat\")",
    "crumbs": [
      "datatype & structure",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>datatype and structure exercise</span>"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "3  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "4  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "References"
    ]
  }
]